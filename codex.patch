diff --git a/Build1.1Beta/TermoSystem v1.1Beta.ino b/Build1.1Beta/TermoSystem v1.1Beta.ino
new file mode 100644
index 0000000000000000000000000000000000000000..375d0ce9ab3d964a6ca2d779c7ca02552fc198c2
--- /dev/null
+++ b/Build1.1Beta/TermoSystem v1.1Beta.ino	
@@ -0,0 +1,4764 @@
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 1: Config & Funzioni di base
+// =========================================================
+
+#include <Arduino.h>
+#include <Wire.h>
+#include <U8g2lib.h>
+#include <ESP8266WiFi.h>
+#include <ESP8266WebServer.h>
+#include <ESP8266httpUpdate.h>
+#include <EEPROM.h>
+#include <PubSubClient.h>
+#include <math.h>
+#include <time.h>
+#include <WiFiClientSecure.h>
+
+// ====== Prototipi funzioni usate prima di essere definite ======
+void applyPumpState(bool on);
+void updatePumpLogic();
+void addHistorySample();
+
+void handleRoot();
+void handleWifiPage();
+void handleSaveWifi();
+void handleApiStatus();
+void handleApiSettingsGet();
+void handleApiSettingsPost();
+void handleApiHistory();
+void handleApp();
+void setupWebServerRoutes();
+
+// =============================
+//  VERSIONE
+// =============================
+#define FW_VERSION "TermoSystem v1.2.1"
+
+// =============================
+//  PIN DEFINITIONS
+// =============================
+
+// I2C
+#define SDA_PIN 14   // D5
+#define SCL_PIN 12   // D6
+
+// PULSANTI
+const int PIN_BTN_UP     = 4;   // D2
+const int PIN_BTN_DOWN   = 5;   // D1
+const int PIN_BTN_SELECT = 13;  // D7 (OK)
+
+// RELÈ
+const int PIN_RELE_POMPA = 2;   // D4
+const int PIN_RELE_AUX   = 16;  // D0 (AUX)
+
+// NTC / ANALOG
+const int PIN_NTC_P1_MAX = A0;  // per ora 1 sola NTC collegata qui
+
+// =============================
+//  DISPLAY PRINCIPALE GM12864
+// =============================
+U8G2_ST7567_ENH_DG128064I_F_HW_I2C mainDisp(
+  U8G2_R0,
+  U8X8_PIN_NONE
+);
+
+// =============================
+//  DISPLAY OLED SECONDARIO
+// =============================
+U8G2_SSD1306_128X64_NONAME_F_HW_I2C oled(
+  U8G2_R0,
+  U8X8_PIN_NONE
+);
+
+// =============================
+//  WEB SERVER
+// =============================
+ESP8266WebServer server(80);
+
+// =============================
+//  EEPROM LAYOUT
+// =============================
+
+const int EEPROM_SIZE             = 256;
+
+const byte EEPROM_MAGIC_WIFI      = 0x42;
+const byte EEPROM_MAGIC_DISPLAY   = 0x99;
+const byte EEPROM_MAGIC_PUMP      = 0x77;
+const byte EEPROM_MAGIC_GLOBAL    = 0x55;
+
+// WIFI
+const int EEPROM_ADDR_WIFI_MAGIC  = 0;
+const int EEPROM_ADDR_WIFI_SSID   = 1;   // 32 bytes
+const int EEPROM_ADDR_WIFI_PASS   = 33;  // 64 bytes
+
+// DISPLAY
+const int EEPROM_ADDR_DISP_MAGIC  = 97;
+const int EEPROM_ADDR_DISP_CONTR  = 98;
+const int EEPROM_ADDR_DISP_FLIP   = 99;
+
+// PUMP
+const int EEPROM_ADDR_PUMP_MAGIC  = 120;
+const int EEPROM_ADDR_PUMP_SET    = 121; // float (4 bytes) - temperatura di set (ON)
+                                         // (OFF = set - isteresi)
+
+// GLOBAL SETTINGS (tema, orologio, AUX, sensori, etc.)
+const int EEPROM_ADDR_GLOBAL_MAGIC     = 140;
+const int EEPROM_ADDR_GLOBAL_THEME     = 141; // uint8_t
+const int EEPROM_ADDR_GLOBAL_USE_NTP   = 142; // uint8_t (0/1)
+const int EEPROM_ADDR_GLOBAL_IS_24H    = 143; // uint8_t (0/1)
+const int EEPROM_ADDR_GLOBAL_TZ_INDEX  = 144; // uint8_t
+const int EEPROM_ADDR_GLOBAL_AUX_STATE = 145; // uint8_t (0/1)
+const int EEPROM_ADDR_GLOBAL_LANG      = 146; // uint8_t (0=IT,1=EN)
+const int EEPROM_ADDR_GLOBAL_SCREENSAVER = 147; // uint8_t (0=NONE,1=ANIM,2=OFF)
+const int EEPROM_ADDR_GLOBAL_SENSE_EN  = 150; // 4 bits per sonde attive
+
+// =============================
+//  MODALITÀ & UI
+// =============================
+
+bool diagMode = false;   // se OK premuto all'avvio
+
+// Stati UI principali
+enum UiState {
+  UI_DASHBOARD,
+  UI_MENU,
+  UI_STATUS,
+  UI_PUMP,
+  UI_DISPLAY_SETTINGS,
+  UI_TIME_SETTINGS,
+  UI_SYSTEM_SETTINGS,
+  UI_THEME_SELECT,
+  UI_LANGUAGE_SELECT,
+  UI_OTA_UPDATE,
+  UI_FACTORY_RESET,
+  UI_SCREENSAVER_SETTINGS,
+  UI_SCREENSAVER,
+  UI_DIAG,
+  UI_INFO
+};
+
+UiState uiState = UI_DASHBOARD;
+
+// =============================
+//  TEMI DISPLAY
+// =============================
+
+enum ThemeId : uint8_t {
+  THEME_CLASSIC = 0,      // layout classico tecnico
+  THEME_TECHNO,           // stile più "tech"
+  THEME_DARKLINES,        // molto minimale a linee
+  THEME_WAVE,             // con "onde" / tubi più evidenti
+  THEME_CHRISTMAS,        // tema natalizio
+  THEME_COUNT
+};
+
+struct ThemeConfig {
+  const char* name;
+  // Qui potresti aggiungere in futuro parametri grafici specifici
+  // (ad es. se usare bordi doppi, tipo di icone, ecc.)
+};
+
+const ThemeConfig THEMES[THEME_COUNT] = {
+  { "Classic"     },
+  { "Techno"      },
+  { "Dark Lines"  },
+  { "Wave Flow"   },
+  { "Christmas"   }
+};
+
+ThemeId currentTheme = THEME_CLASSIC;
+
+// =============================
+//  LINGUE
+// =============================
+
+enum LanguageId : uint8_t {
+  LANG_IT = 0,
+  LANG_EN,
+  LANG_COUNT
+};
+
+LanguageId currentLanguage = LANG_IT;
+
+const char* tr(const char* it, const char* en) {
+  switch (currentLanguage) {
+    case LANG_EN: return en;
+    case LANG_IT:
+    default:      return it;
+  }
+}
+
+const char* languageName(LanguageId lang) {
+  switch (lang) {
+    case LANG_IT: return "Italiano";
+    case LANG_EN: return "English";
+    default:      return "??";
+  }
+}
+
+// =============================
+//  WIFI CONFIG
+// =============================
+
+struct WifiConfig {
+  char ssid[32];
+  char password[64];
+};
+
+WifiConfig wifiConf;
+bool wifiConfigured = false;
+bool wifiConnected  = false;
+bool apMode         = false;
+
+// =============================
+//  MQTT (widget / accesso remoto)
+// =============================
+
+const char* MQTT_HOST  = ""; // es: "192.168.1.10"
+const uint16_t MQTT_PORT = 1883;
+const char* MQTT_USER  = "";
+const char* MQTT_PASS  = "";
+const char* MQTT_TOPIC = "termosystem/status";
+
+WiFiClient mqttNetClient;
+PubSubClient mqttClient(mqttNetClient);
+unsigned long lastMqttPublishMs = 0;
+const unsigned long MQTT_PUBLISH_INTERVAL_MS = 10000;
+
+// =============================
+//  OTA UPDATE
+// =============================
+
+// Imposta l'URL RAW del tuo repo GitHub al file OTA/LiveUpdate.bin
+const char* OTA_FIRMWARE_URL = "https://raw.githubusercontent.com/USER/REPO/main/OTA/LiveUpdate.bin";
+bool otaStartRequested = false;
+bool otaInProgress = false;
+int  otaProgress = -1;
+int  otaLastError = 0;
+
+// =============================
+//  PULSANTI (debounce)
+// =============================
+
+bool lastUpState     = HIGH;
+bool lastDownState   = HIGH;
+bool lastSelectState = HIGH;
+unsigned long lastBtnTime = 0;
+const unsigned long DEBOUNCE_MS   = 150;
+const unsigned long LONG_PRESS_MS = 800;
+
+bool upPressed     = false;
+bool downPressed   = false;
+bool selectPressed = false;
+
+// =============================
+//  SALVASCHERMO
+// =============================
+
+enum ScreenSaverMode : uint8_t {
+  SCREENSAVER_NONE = 0,
+  SCREENSAVER_ANIM,
+  SCREENSAVER_OFF
+};
+
+ScreenSaverMode screenSaverMode = SCREENSAVER_NONE;
+unsigned long lastUserActivityMs = 0;
+bool displaySleeping = false;
+const unsigned long SCREENSAVER_TIMEOUT_MS = 60000;
+
+// =============================
+//  RELÈ & POMPA LOGIC
+// =============================
+
+bool relayPumpActiveLow = true;  // se relè pilotato a logica invertita
+bool relayAuxActiveLow  = true;
+
+// Pompa: AUTO / FORZATA / SPENTA
+enum PumpMode {
+  PUMP_AUTO,
+  PUMP_FORCE_ON,
+  PUMP_FORCE_OFF
+};
+
+PumpMode pumpMode        = PUMP_AUTO;
+bool     pumpRelayState  = false;  // stato reale relè
+bool     auxRelayState   = false;  // stato reale AUX
+
+// Isteresi: ON a temperatura di set, OFF 1.5°C sotto
+float pumpSetTemp = 45.0f;             // soglia di partenza pompa
+const float PUMP_HYST  = 1.5f;         // isteresi spegnimento
+bool  pumpLogicInit    = false;        // per evitare click all'avvio
+
+void applyPumpRelay(bool on) {
+  pumpRelayState = on;
+  if (relayPumpActiveLow) {
+    digitalWrite(PIN_RELE_POMPA, on ? LOW : HIGH);
+  } else {
+    digitalWrite(PIN_RELE_POMPA, on ? HIGH : LOW);
+  }
+}
+
+void applyAuxRelay(bool on) {
+  auxRelayState = on;
+  if (relayAuxActiveLow) {
+    digitalWrite(PIN_RELE_AUX, on ? LOW : HIGH);
+  } else {
+    digitalWrite(PIN_RELE_AUX, on ? HIGH : LOW);
+  }
+}
+
+// =============================
+//  SONDE & PUFFER
+// =============================
+
+// 4 sonde: P1 max, P1 min, P2 max, P2 min –
+// al momento solo P1 max è collegata alla NTC reale su A0;
+// le altre sono placeholder per future espansioni.
+
+enum SondaId {
+  SONDA_P1_MAX = 0,
+  SONDA_P1_MIN,
+  SONDA_P2_MAX,
+  SONDA_P2_MIN,
+  SONDA_COUNT
+};
+
+struct SondaData {
+  float tempC;
+  bool  ok;
+  bool  enabled;  // attivabile/disattivabile da menu
+};
+
+SondaData sonde[SONDA_COUNT];
+
+// Dati puffer (aggregati, derivati dalle sonde)
+struct PufferData {
+  float tMax;
+  float tMin;
+  bool  enabled;
+};
+
+PufferData puffer1;
+PufferData puffer2;
+
+// =============================
+//  STATISTICHE GIORNALIERE
+// =============================
+
+unsigned long dailyPumpOnMs = 0;
+int dailyLowTempEvents = 0;
+float dailyMinP1 = NAN;
+float dailyMaxP1 = NAN;
+int dailyStamp = -1;
+bool lowTempState = false;
+unsigned long lastMetricsMs = 0;
+
+int getDayStamp() {
+  struct tm info;
+  if (getLocalTimeSafe(&info)) {
+    return (info.tm_year * 1000) + info.tm_yday;
+  }
+  return (int)(millis() / 86400000UL);
+}
+
+void updateDailyMetrics() {
+  unsigned long now = millis();
+  int stamp = getDayStamp();
+  if (dailyStamp == -1) dailyStamp = stamp;
+  if (stamp != dailyStamp) {
+    dailyStamp = stamp;
+    dailyPumpOnMs = 0;
+    dailyLowTempEvents = 0;
+    dailyMinP1 = NAN;
+    dailyMaxP1 = NAN;
+    lowTempState = false;
+  }
+
+  if (lastMetricsMs == 0) lastMetricsMs = now;
+  unsigned long delta = now - lastMetricsMs;
+  lastMetricsMs = now;
+  if (pumpRelayState) {
+    dailyPumpOnMs += delta;
+  }
+
+  if (!isnan(puffer1.tMax)) {
+    if (isnan(dailyMinP1) || puffer1.tMax < dailyMinP1) dailyMinP1 = puffer1.tMax;
+    if (isnan(dailyMaxP1) || puffer1.tMax > dailyMaxP1) dailyMaxP1 = puffer1.tMax;
+  }
+
+  float threshold = pumpSetTemp - PUMP_HYST;
+  if (!isnan(puffer1.tMax)) {
+    bool below = puffer1.tMax < threshold;
+    if (below && !lowTempState) {
+      dailyLowTempEvents++;
+    }
+    lowTempState = below;
+  }
+}
+
+// =============================
+//  HOPPER PELLET (placeholder)
+// =============================
+
+struct HopperData {
+  float percent;     // 0..100, per ora N/A -> -1
+  bool  hasSensor;   // quando arriverà il sensore di prossimità
+};
+
+HopperData hopper = { -1.0f, false };
+
+// =============================
+//  PERIPHERAL STATUS (per startup diagnostico)
+// =============================
+
+struct PeripheralStatus {
+  bool present;  // presente fisicamente nel progetto
+  bool ok;       // testata e funzionante all'avvio
+};
+
+PeripheralStatus stMainDisplay  = { true,  false };
+PeripheralStatus stOledDisplay  = { true,  false };
+PeripheralStatus stRelayPump    = { true,  false };
+PeripheralStatus stRelayAux     = { true,  false };
+PeripheralStatus stSonde[SONDA_COUNT];
+PeripheralStatus stHopper       = { false, false }; // per ora sensore non presente
+
+// =============================
+//  VOLTAGGIO ALIMENTAZIONE
+// =============================
+
+// Per ora valore "logico" di 5V, in futuro si può collegare un partitore sul pin ADC.
+float supplyVoltage5V = 5.0f;
+
+// =============================
+//  VCC MCU
+// =============================
+
+// Se vorrai, potremo usare ADC interno calibrato;
+// per ora lasciamo un valore fisso "di riferimento"
+float getVcc() {
+  return 3.30f;
+}
+
+// =============================
+//  UPTIME FORMAT
+// =============================
+
+void formatUptime(char* buf, size_t len) {
+  unsigned long sec = millis() / 1000;
+  unsigned long h = sec / 3600;
+  unsigned long m = (sec % 3600) / 60;
+  unsigned long s = sec % 60;
+  snprintf(buf, len, "%luh %02lum %02lus", h, m, s);
+}
+
+// =============================
+//  ORARIO / NTP / FUSO
+// =============================
+
+struct TimeZoneInfo {
+  const char* city;
+  int32_t offsetMinutes;  // offset rispetto a UTC, senza DST (per semplicità)
+};
+
+const TimeZoneInfo TIMEZONES[] = {
+  { "Roma",        60 },   // Europe/Rome (senza DST)
+  { "Londra",       0 },   // Europe/London
+  { "New York",  -300 },   // America/New_York
+  { "Tokyo",      540 },   // Asia/Tokyo
+  { "Sydney",     600 },   // Australia/Sydney
+  { "Dubai",      240 },   // Asia/Dubai
+  { "Los Angeles",-480 },  // America/Los_Angeles
+};
+const uint8_t TIMEZONES_COUNT = sizeof(TIMEZONES) / sizeof(TIMEZONES[0]);
+
+bool     clockUseNtp  = true;
+bool     clockIs24h   = true;
+uint8_t  clockTzIndex = 0;   // default: Roma
+
+void setupTimeConfig() {
+  if (clockTzIndex >= TIMEZONES_COUNT) clockTzIndex = 0;
+  const TimeZoneInfo& tz = TIMEZONES[clockTzIndex];
+
+  // offset in secondi rispetto a UTC
+  long gmtOffsetSec = tz.offsetMinutes * 60;
+  long daylightOffsetSec = 0; // per semplicità, niente DST dinamico qui
+
+  if (clockUseNtp && wifiConnected) {
+    configTime(gmtOffsetSec, daylightOffsetSec,
+               "pool.ntp.org", "time.nist.gov", "time.google.com");
+  }
+}
+
+bool getLocalTimeSafe(struct tm* info) {
+  time_t now = time(nullptr);
+  if (now < 100000) return false; // non ancora sincronizzato
+  localtime_r(&now, info);
+  return true;
+}
+
+void formatTimeString(char* buf, size_t len) {
+  struct tm t;
+  if (!getLocalTimeSafe(&t)) {
+    snprintf(buf, len, "--:--");
+    return;
+  }
+
+  if (clockIs24h) {
+    snprintf(buf, len, "%02d:%02d", t.tm_hour, t.tm_min);
+  } else {
+    int h = t.tm_hour;
+    int m = t.tm_min;
+    bool pm = (h >= 12);
+    int h12 = h % 12;
+    if (h12 == 0) h12 = 12;
+    snprintf(buf, len, "%2d:%02d%s", h12, m, pm ? "p" : "a");
+  }
+}
+
+bool isChristmasToday() {
+  struct tm t;
+  if (!getLocalTimeSafe(&t)) return false;
+  // tm_mon: 0=Jan...11=Dec
+  return (t.tm_mon == 11 && t.tm_mday == 25);
+}
+
+void autoSelectChristmasThemeIfNeeded() {
+  if (isChristmasToday()) {
+    currentTheme = THEME_CHRISTMAS;
+  }
+}
+
+// =============================
+//  BUTTON HANDLING
+// =============================
+
+void readButtons() {
+  upPressed = downPressed = selectPressed = false;
+
+  unsigned long now = millis();
+  if (now - lastBtnTime < DEBOUNCE_MS) return;
+
+  bool upState     = digitalRead(PIN_BTN_UP);
+  bool downState   = digitalRead(PIN_BTN_DOWN);
+  bool selectState = digitalRead(PIN_BTN_SELECT);
+
+  if (lastUpState == HIGH && upState == LOW) {
+    upPressed = true;
+    lastBtnTime = now;
+  }
+  if (lastDownState == HIGH && downState == LOW) {
+    downPressed = true;
+    lastBtnTime = now;
+  }
+  if (lastSelectState == HIGH && selectState == LOW) {
+    selectPressed = true;
+    lastBtnTime = now;
+  }
+
+  if (upPressed || downPressed || selectPressed) {
+    lastUserActivityMs = now;
+    if (displaySleeping) {
+      mainDisp.setPowerSave(0);
+      displaySleeping = false;
+    }
+  }
+
+  lastUpState     = upState;
+  lastDownState   = downState;
+  lastSelectState = selectState;
+}
+
+// =============================
+//  WIFI CONFIG LOAD/SAVE
+// =============================
+
+void loadWifiConfig() {
+  byte magic = EEPROM.read(EEPROM_ADDR_WIFI_MAGIC);
+  if (magic != EEPROM_MAGIC_WIFI) {
+    wifiConfigured = false;
+    memset(&wifiConf, 0, sizeof(wifiConf));
+    return;
+  }
+
+  for (int i = 0; i < 32; i++) {
+    wifiConf.ssid[i] = EEPROM.read(EEPROM_ADDR_WIFI_SSID + i);
+  }
+  for (int i = 0; i < 64; i++) {
+    wifiConf.password[i] = EEPROM.read(EEPROM_ADDR_WIFI_PASS + i);
+  }
+  wifiConf.ssid[31]     = '\0';
+  wifiConf.password[63] = '\0';
+
+  if (wifiConf.ssid[0] == 0xFF || wifiConf.ssid[0] == '\0') {
+    wifiConfigured = false;
+  } else {
+    wifiConfigured = true;
+  }
+}
+
+void saveWifiConfig(const char* ssid, const char* password) {
+  memset(&wifiConf, 0, sizeof(wifiConf));
+  strncpy(wifiConf.ssid, ssid, sizeof(wifiConf.ssid) - 1);
+  strncpy(wifiConf.password, password, sizeof(wifiConf.password) - 1);
+
+  EEPROM.write(EEPROM_ADDR_WIFI_MAGIC, EEPROM_MAGIC_WIFI);
+  for (int i = 0; i < 32; i++) {
+    EEPROM.write(EEPROM_ADDR_WIFI_SSID + i, wifiConf.ssid[i]);
+  }
+  for (int i = 0; i < 64; i++) {
+    EEPROM.write(EEPROM_ADDR_WIFI_PASS + i, wifiConf.password[i]);
+  }
+  EEPROM.commit();
+}
+
+void connectToWifi() {
+  if (!wifiConfigured) {
+    wifiConnected = false;
+    return;
+  }
+  WiFi.mode(WIFI_STA);
+  WiFi.begin(wifiConf.ssid, wifiConf.password);
+  unsigned long start = millis();
+  while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
+    delay(200);
+  }
+  wifiConnected = (WiFi.status() == WL_CONNECTED);
+}
+
+void startAPModeAlways() {
+  WiFi.mode(WIFI_AP_STA);
+  WiFi.softAP("TermoSystemWifi", "12345678");
+  apMode = true;
+}
+
+bool mqttConfigured() {
+  return MQTT_HOST && MQTT_HOST[0] != '\0';
+}
+
+void setupMqtt() {
+  if (!mqttConfigured()) return;
+  mqttClient.setServer(MQTT_HOST, MQTT_PORT);
+}
+
+void publishMqttStatus() {
+  if (!mqttClient.connected()) return;
+  String payload = "{";
+  payload += "\"p1Max\":";
+  if (!isnan(puffer1.tMax)) payload += String(puffer1.tMax, 1); else payload += "\"NaN\"";
+  payload += ",\"p2Max\":";
+  if (!isnan(puffer2.tMax)) payload += String(puffer2.tMax, 1); else payload += "\"NaN\"";
+  payload += ",\"pumpOn\":" + String(pumpRelayState ? "true" : "false");
+  payload += ",\"hopper\":";
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    payload += String(hopper.percent, 0);
+  } else {
+    payload += "\"NaN\"";
+  }
+  payload += ",\"dailyPumpOnMin\":" + String((int)(dailyPumpOnMs / 60000UL));
+  payload += ",\"dailyLowTempEvents\":" + String(dailyLowTempEvents);
+  payload += "}";
+  mqttClient.publish(MQTT_TOPIC, payload.c_str(), true);
+}
+
+void updateMqtt() {
+  if (!mqttConfigured() || !wifiConnected) return;
+  if (!mqttClient.connected()) {
+    String clientId = String("TermoSystem-") + String(ESP.getChipId(), HEX);
+    if (MQTT_USER[0] != '\0') {
+      mqttClient.connect(clientId.c_str(), MQTT_USER, MQTT_PASS);
+    } else {
+      mqttClient.connect(clientId.c_str());
+    }
+  }
+  mqttClient.loop();
+
+  unsigned long now = millis();
+  if (mqttClient.connected() && (now - lastMqttPublishMs >= MQTT_PUBLISH_INTERVAL_MS)) {
+    lastMqttPublishMs = now;
+    publishMqttStatus();
+  }
+}
+
+// =============================
+//  DISPLAY CONFIG LOAD/SAVE
+// =============================
+
+uint8_t mainContrast = 200; // 0-255
+uint8_t mainFlip     = 0;   // 0=normale,1=flip
+
+void loadDisplayConfig() {
+  byte magic = EEPROM.read(EEPROM_ADDR_DISP_MAGIC);
+  if (magic != EEPROM_MAGIC_DISPLAY) {
+    mainContrast = 200;
+    mainFlip     = 0;
+    return;
+  }
+  byte c = EEPROM.read(EEPROM_ADDR_DISP_CONTR);
+  if (c == 0xFF) c = 200;
+  mainContrast = c;
+
+  byte f = EEPROM.read(EEPROM_ADDR_DISP_FLIP);
+  mainFlip = (f > 0) ? 1 : 0;
+}
+
+void saveDisplayConfig() {
+  EEPROM.write(EEPROM_ADDR_DISP_MAGIC, EEPROM_MAGIC_DISPLAY);
+  EEPROM.write(EEPROM_ADDR_DISP_CONTR, mainContrast);
+  EEPROM.write(EEPROM_ADDR_DISP_FLIP,  mainFlip);
+  EEPROM.commit();
+}
+
+// =============================
+//  PUMP CONFIG (SET TEMP + ISTERESI)
+// =============================
+
+void loadPumpConfig() {
+  byte magic = EEPROM.read(EEPROM_ADDR_PUMP_MAGIC);
+  if (magic != EEPROM_MAGIC_PUMP) {
+    pumpSetTemp = 45.0f;
+    return;
+  }
+  union {
+    float f;
+    uint8_t b[4];
+  } u;
+  for (int i = 0; i < 4; i++) {
+    u.b[i] = EEPROM.read(EEPROM_ADDR_PUMP_SET + i);
+  }
+  if (isnan(u.f) || u.f < 10 || u.f > 90) {
+    pumpSetTemp = 45.0f;
+  } else {
+    pumpSetTemp = u.f;
+  }
+}
+
+void savePumpConfig() {
+  EEPROM.write(EEPROM_ADDR_PUMP_MAGIC, EEPROM_MAGIC_PUMP);
+  union {
+    float f;
+    uint8_t b[4];
+  } u;
+  u.f = pumpSetTemp;
+  for (int i = 0; i < 4; i++) {
+    EEPROM.write(EEPROM_ADDR_PUMP_SET + i, u.b[i]);
+  }
+  EEPROM.commit();
+}
+
+// =============================
+//  GLOBAL CONFIG (tema, orologio, AUX, sonde)
+// =============================
+
+void loadGlobalConfig() {
+  byte magic = EEPROM.read(EEPROM_ADDR_GLOBAL_MAGIC);
+  if (magic != EEPROM_MAGIC_GLOBAL) {
+    currentTheme   = THEME_CLASSIC;
+    clockUseNtp    = true;
+    clockIs24h     = true;
+    clockTzIndex   = 0;
+    auxRelayState  = false;
+    currentLanguage = LANG_IT;
+    screenSaverMode = SCREENSAVER_NONE;
+    for (int i = 0; i < SONDA_COUNT; i++) {
+      sonde[i].enabled = true;  // di default tutte attive
+    }
+    return;
+  }
+
+  uint8_t t = EEPROM.read(EEPROM_ADDR_GLOBAL_THEME);
+  if (t >= THEME_COUNT) t = THEME_CLASSIC;
+  currentTheme = (ThemeId)t;
+
+  uint8_t ntp  = EEPROM.read(EEPROM_ADDR_GLOBAL_USE_NTP);
+  uint8_t h24  = EEPROM.read(EEPROM_ADDR_GLOBAL_IS_24H);
+  uint8_t tz   = EEPROM.read(EEPROM_ADDR_GLOBAL_TZ_INDEX);
+  uint8_t aux  = EEPROM.read(EEPROM_ADDR_GLOBAL_AUX_STATE);
+  uint8_t lang = EEPROM.read(EEPROM_ADDR_GLOBAL_LANG);
+  uint8_t saver= EEPROM.read(EEPROM_ADDR_GLOBAL_SCREENSAVER);
+  uint8_t sen  = EEPROM.read(EEPROM_ADDR_GLOBAL_SENSE_EN);
+
+  clockUseNtp  = (ntp != 0);
+  clockIs24h   = (h24 != 0);
+  clockTzIndex = (tz >= TIMEZONES_COUNT) ? 0 : tz;
+  auxRelayState = (aux != 0);
+  if (lang >= LANG_COUNT) lang = LANG_IT;
+  currentLanguage = (LanguageId)lang;
+  if (saver > SCREENSAVER_OFF) saver = SCREENSAVER_NONE;
+  screenSaverMode = (ScreenSaverMode)saver;
+
+  for (int i = 0; i < SONDA_COUNT; i++) {
+    bool en = (sen & (1 << i)) != 0;
+    sonde[i].enabled = en;
+  }
+}
+
+void saveGlobalConfig() {
+  EEPROM.write(EEPROM_ADDR_GLOBAL_MAGIC, EEPROM_MAGIC_GLOBAL);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_THEME,    (uint8_t)currentTheme);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_USE_NTP,  clockUseNtp ? 1 : 0);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_IS_24H,   clockIs24h  ? 1 : 0);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_TZ_INDEX, clockTzIndex);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_AUX_STATE, auxRelayState ? 1 : 0);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_LANG,     (uint8_t)currentLanguage);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_SCREENSAVER, (uint8_t)screenSaverMode);
+
+  uint8_t sen = 0;
+  for (int i = 0; i < SONDA_COUNT; i++) {
+    if (sonde[i].enabled) sen |= (1 << i);
+  }
+  EEPROM.write(EEPROM_ADDR_GLOBAL_SENSE_EN, sen);
+
+  EEPROM.commit();
+}
+
+void resetFactoryDefaults() {
+  EEPROM.write(EEPROM_ADDR_WIFI_MAGIC,    0x00);
+  EEPROM.write(EEPROM_ADDR_DISP_MAGIC,    0x00);
+  EEPROM.write(EEPROM_ADDR_PUMP_MAGIC,    0x00);
+  EEPROM.write(EEPROM_ADDR_GLOBAL_MAGIC,  0x00);
+  EEPROM.commit();
+}
+
+// =============================
+//  LETTURA NTC P1 MAX
+// =============================
+
+float readNtcTempOnA0() {
+  const float VCC     = 3.3;       // tensione logica
+  const float R_FIXED = 10000.0;   // 10k
+  const float BETA    = 3950.0;    // NTC tipica
+  const float T0      = 298.15;    // 25°C K
+  const float R0      = 10000.0;   // 10k @ 25°C
+
+  int adc = analogRead(PIN_NTC_P1_MAX); // 0..1023
+  float v = adc * (VCC / 1023.0);
+
+  if (v <= 0.01 || v >= (VCC - 0.01)) {
+    return NAN;
+  }
+
+  float r_ntc = (v * R_FIXED) / (VCC - v);
+
+  float invT = 1.0 / T0 + (1.0 / BETA) * log(r_ntc / R0);
+  float T = 1.0 / invT;
+  float Tc = T - 273.15;
+
+  return Tc;
+}
+
+// =============================
+//  UPDATE SENSORS (4 SONDE)
+// =============================
+
+void updateSensors() {
+  // Reset OK flag
+  for (int i = 0; i < SONDA_COUNT; i++) {
+    sonde[i].ok = false;
+  }
+
+  // SONDA_P1_MAX = reale
+  if (sonde[SONDA_P1_MAX].enabled) {
+    float t = readNtcTempOnA0();
+    if (!isnan(t) && t > -20 && t < 120) {
+      sonde[SONDA_P1_MAX].tempC = t;
+      sonde[SONDA_P1_MAX].ok    = true;
+      stSonde[SONDA_P1_MAX].ok  = true;
+    } else {
+      sonde[SONDA_P1_MAX].ok    = false;
+    }
+  }
+
+  // Le altre sonde sono placeholder -> N/A
+  for (int i = 1; i < SONDA_COUNT; i++) {
+    if (sonde[i].enabled) {
+      sonde[i].tempC = NAN;
+      sonde[i].ok    = false;
+    }
+  }
+
+  // Aggregazione puffer
+  // Puffer1: P1_MAX / P1_MIN
+  if (sonde[SONDA_P1_MAX].ok) {
+    puffer1.tMax = sonde[SONDA_P1_MAX].tempC;
+  } else {
+    puffer1.tMax = NAN;
+  }
+  if (sonde[SONDA_P1_MIN].ok) {
+    puffer1.tMin = sonde[SONDA_P1_MIN].tempC;
+  } else {
+    puffer1.tMin = NAN;
+  }
+
+  // Puffer2: P2_MAX / P2_MIN
+  if (sonde[SONDA_P2_MAX].ok) {
+    puffer2.tMax = sonde[SONDA_P2_MAX].tempC;
+  } else {
+    puffer2.tMax = NAN;
+  }
+  if (sonde[SONDA_P2_MIN].ok) {
+    puffer2.tMin = sonde[SONDA_P2_MIN].tempC;
+  } else {
+    puffer2.tMin = NAN;
+  }
+}
+
+// =============================
+//  LOGICA POMPA CON ISTERESI
+// =============================
+
+const char* pumpModeToString() {
+  switch (pumpMode) {
+    case PUMP_AUTO:      return "AUTO";
+    case PUMP_FORCE_ON:  return "FORZATA ON";
+    case PUMP_FORCE_OFF: return "FORZATA OFF";
+  }
+  return "?";
+}
+
+void updatePumpLogic() {
+  // Evitiamo click casuali all'avvio:
+  if (!pumpLogicInit) {
+    applyPumpRelay(false);   // pompa spenta fino a prima valutazione sensata
+    pumpLogicInit = true;
+  }
+
+  switch (pumpMode) {
+    case PUMP_AUTO: {
+      // Usiamo P1_MAX come riferimento per la logica
+      if (!sonde[SONDA_P1_MAX].ok) {
+        applyPumpRelay(false);
+      } else {
+        float t = sonde[SONDA_P1_MAX].tempC;
+
+        // ON:   quando la temp supera il setpoint
+        if (!pumpRelayState && t >= pumpSetTemp) {
+          applyPumpRelay(true);
+        }
+        // OFF: quando scende di 1.5°C sotto il setpoint
+        else if (pumpRelayState && t <= (pumpSetTemp - PUMP_HYST)) {
+          applyPumpRelay(false);
+        }
+        // altrimenti mantiene lo stato attuale (niente click)
+      }
+      break;
+    }
+
+    case PUMP_FORCE_ON:
+      applyPumpRelay(true);
+      break;
+
+    case PUMP_FORCE_OFF:
+      applyPumpRelay(false);
+      break;
+  }
+}
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 2: setup() + startup stile Linux + animazione logo
+// =========================================================
+
+// Forward declarations di cose che arriveranno nei blocchi successivi
+void setupWebServerRoutes();  // definita nel blocco WebApp
+void drawOledDiag();          // versione runtime, definita più avanti
+void drawOledVitals();        // versione runtime, definita più avanti
+
+// =============================
+//  HELPER: Aggiorna stato periferiche
+// =============================
+void updatePeripheralStatus() {
+  // Display principali considerati presenti
+  stMainDisplay.present = true;
+  stOledDisplay.present = true;
+  stRelayPump.present   = true;
+  stRelayAux.present    = true;
+
+  // Dopo l'inizializzazione li mettiamo a OK
+  stMainDisplay.ok = true;
+  stOledDisplay.ok = true;
+  stRelayPump.ok   = true;
+  stRelayAux.ok    = true;
+
+  // Sonde: tutte "presenti" (placeholder), OK se hanno dato misura valida
+  for (int i = 0; i < SONDA_COUNT; i++) {
+    stSonde[i].present = true;
+    stSonde[i].ok      = sonde[i].ok;
+  }
+
+  // Hopper: per ora sensore non installato
+  stHopper.present = hopper.hasSensor;
+  stHopper.ok      = hopper.hasSensor;  // sarà OK quando realmente presente
+}
+
+// =============================
+//  STARTUP / BOOT "STILE LINUX"
+// =============================
+
+void showLinuxLikeBoot() {
+  mainDisp.clearBuffer();
+  mainDisp.setFont(u8g2_font_5x8_tr);
+
+  int y = 10;
+  mainDisp.drawStr(0, y, "TermoSystem boot log...");
+  y += 10;
+
+  const char* names[] = {
+    "Sonda P1 MAX",
+    "Sonda P1 MIN",
+    "Sonda P2 MAX",
+    "Sonda P2 MIN",
+    "Pompa",
+    "Relè AUX",
+    "LCD GM12864",
+    "OLED 128x64",
+    "Hopper Sensor"
+  };
+
+  bool oks[] = {
+    sonde[SONDA_P1_MAX].ok,
+    sonde[SONDA_P1_MIN].ok,
+    sonde[SONDA_P2_MAX].ok,
+    sonde[SONDA_P2_MIN].ok,
+    true,
+    true,
+    true,
+    true,
+    hopper.hasSensor
+  };
+
+  const int N = sizeof(names) / sizeof(names[0]);
+
+  for (int i = 0; i < N && y < 60; i++) {
+    char buf[40];
+    const char* s = oks[i] ? "OK " : "N/A";
+    snprintf(buf, sizeof(buf), "[%s] %s", s, names[i]);
+    mainDisp.drawStr(0, y, buf);
+    y += 8;
+  }
+
+  mainDisp.sendBuffer();
+  delay(800);
+}
+
+// Schermata diagnostica di avvio "riassuntiva"
+void showStartupDiagScreen() {
+  mainDisp.clearBuffer();
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 10, "Diagnostica Avvio");
+
+  int y = 24;
+
+  if (!sonde[SONDA_P1_MAX].ok) {
+    mainDisp.drawStr(0, y, "E01: Sonda P1 MAX");
+    y += 10;
+  }
+  if (!sonde[SONDA_P2_MAX].ok) {
+    mainDisp.drawStr(0, y, "E02: Sonda P2 MAX");
+    y += 10;
+  }
+  if (!wifiConnected) {
+    mainDisp.drawStr(0, y, "W01: WiFi non connesso");
+    y += 10;
+  }
+  float vcc = getVcc();
+  if (vcc < 3.0 || vcc > 3.6) {
+    mainDisp.drawStr(0, y, "W02: VCC fuori range");
+    y += 10;
+  }
+
+  if (y == 24) {
+    mainDisp.drawStr(0, 30, "Nessun errore critico");
+  }
+
+  mainDisp.sendBuffer();
+  delay(1000);
+}
+
+// Diagnostica di avvio sul piccolo OLED
+void showStartupDiagOled() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_5x8_tr);
+  oled.drawStr(0, 8, "BOOT DIAG");
+
+  int y = 18;
+  bool errorFound = false;
+
+  if (!sonde[SONDA_P1_MAX].ok) {
+    oled.drawStr(0, y, "E01 P1 MAX");
+    y += 8;
+    errorFound = true;
+  }
+  if (!wifiConnected) {
+    oled.drawStr(0, y, "W01 WiFi NO");
+    y += 8;
+    errorFound = true;
+  }
+  float vcc = getVcc();
+  if (vcc < 3.0 || vcc > 3.6) {
+    oled.drawStr(0, y, "W02 VCC RANGE");
+    y += 8;
+    errorFound = true;
+  }
+
+  if (!errorFound) {
+    oled.drawStr(0, y, "NESSUN ERRORE");
+  }
+
+  oled.sendBuffer();
+  delay(1000);
+}
+
+// Animazione logo TermoSystem incrociato
+void showLogoAnimation() {
+  const char* left  = "Termo";
+  const char* right = "System";
+
+  int wLeft  = mainDisp.getStrWidth(left);
+  int wRight = mainDisp.getStrWidth(right);
+
+  int yCenter = 40;
+  int centerX = 64;
+
+  int startLeftX  = 128;
+  int startRightX = -wRight;
+
+  for (int step = 0; step <= 20; step++) {
+    float t = step / 20.0f;
+    int xLeft  = startLeftX  - (int)(t * (startLeftX  - (centerX - wLeft)));
+    int xRight = startRightX + (int)(t * ((centerX) - startRightX));
+
+    mainDisp.clearBuffer();
+
+    mainDisp.setFont(u8g2_font_ncenB14_tr);
+    mainDisp.drawStr(xLeft,  yCenter, left);
+    mainDisp.drawStr(xRight, yCenter + 14, right);
+
+    mainDisp.setFont(u8g2_font_5x8_tr);
+    mainDisp.drawStr(0, 62, "by Stephan W.   ");
+    mainDisp.drawStr(80, 62, FW_VERSION);
+
+    mainDisp.sendBuffer();
+    delay(60);
+  }
+
+  mainDisp.clearBuffer();
+  mainDisp.setFont(u8g2_font_ncenB14_tr);
+  int wAll = mainDisp.getStrWidth("TermoSystem");
+  int xAll = (128 - wAll) / 2;
+  mainDisp.drawStr(xAll, yCenter, "TermoSystem");
+
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  mainDisp.drawStr(0, 62, "by Stephan W.");
+  mainDisp.drawStr(80, 62, FW_VERSION);
+  mainDisp.sendBuffer();
+  delay(1200);
+}
+
+void setup() {
+  // --- Pulsanti ---
+  pinMode(PIN_BTN_UP,     INPUT_PULLUP);
+  pinMode(PIN_BTN_DOWN,   INPUT_PULLUP);
+  pinMode(PIN_BTN_SELECT, INPUT_PULLUP);
+
+  // --- Relè ---
+  // Prima forziamo lo stato OFF logico senza usare la logica di pompa,
+  // così EVITIAMO i click casuali all'avvio.
+  pinMode(PIN_RELE_POMPA, OUTPUT);
+  pinMode(PIN_RELE_AUX,   OUTPUT);
+
+  if (relayPumpActiveLow) digitalWrite(PIN_RELE_POMPA, HIGH);
+  else                    digitalWrite(PIN_RELE_POMPA, LOW);
+
+  if (relayAuxActiveLow)  digitalWrite(PIN_RELE_AUX, HIGH);
+  else                    digitalWrite(PIN_RELE_AUX, LOW);
+
+  pumpRelayState = false;
+  auxRelayState  = false;
+  pumpLogicInit  = false;
+
+  // --- Modalità diagnosi se OK premuto all'avvio ---
+  delay(20);
+  if (digitalRead(PIN_BTN_SELECT) == LOW) {
+    diagMode = true;
+  }
+
+  // --- EEPROM ---
+  EEPROM.begin(EEPROM_SIZE);
+
+  // --- I2C ---
+  Wire.begin(SDA_PIN, SCL_PIN);
+
+  // --- Config di base ---
+  loadWifiConfig();
+  loadDisplayConfig();
+  loadPumpConfig();
+  loadGlobalConfig();
+
+  // --- Display principale ---
+  mainDisp.setI2CAddress(0x3F << 1);   // indirizzo tipico
+  mainDisp.begin();
+  mainDisp.setContrast(mainContrast);
+  mainDisp.setFlipMode(mainFlip);
+
+  // --- OLED ---
+  oled.begin();
+  oled.clearBuffer();
+  oled.sendBuffer();
+
+  // --- WiFi: AP sempre, + STA se configurato ---
+  startAPModeAlways();
+  if (wifiConfigured) {
+    connectToWifi();
+  }
+  setupMqtt();
+
+  // --- Orario / NTP ---
+  setupTimeConfig();
+  autoSelectChristmasThemeIfNeeded();
+
+  // --- Inizializza sensori, puffer, periferiche ---
+  for (int i = 0; i < SONDA_COUNT; i++) {
+    sonde[i].ok      = false;
+    if (!sonde[i].enabled) {
+      stSonde[i].present = true;
+      stSonde[i].ok      = false;
+    }
+  }
+
+  puffer1.enabled = true;
+  puffer2.enabled = true;
+
+  // Prima lettura sensori
+  updateSensors();
+  updatePeripheralStatus();
+
+  // --- WebServer (route definite in altro blocco) ---
+  setupWebServerRoutes();
+  server.begin();
+
+  // --- Sequenza di avvio ---
+  showLinuxLikeBoot();
+  showStartupDiagScreen();
+  showStartupDiagOled();
+  showLogoAnimation();
+
+  // --- Stato iniziale UI ---
+  lastUserActivityMs = millis();
+  uiState = UI_DASHBOARD;
+}
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 3: Top bar + Dashboard + Temi
+// =========================================================
+
+// =============================
+//  COSTANTI GRAFICHE
+// =============================
+
+const float T_DISPLAY_MIN = 20.0f;
+const float T_DISPLAY_MAX = 80.0f;
+
+// Mappa temperatura (°C) in "livello" (0..maxLevel) per uso grafico
+int mapTempToLevel(float temp, int maxLevel) {
+  if (isnan(temp)) return 0;
+  if (temp < T_DISPLAY_MIN) temp = T_DISPLAY_MIN;
+  if (temp > T_DISPLAY_MAX) temp = T_DISPLAY_MAX;
+  float ratio = (temp - T_DISPLAY_MIN) / (T_DISPLAY_MAX - T_DISPLAY_MIN);
+  int level = (int)(ratio * maxLevel);
+  if (level < 0) level = 0;
+  if (level > maxLevel) level = maxLevel;
+  return level;
+}
+
+// =============================
+//  ICONA WIFI + TOP BAR
+// =============================
+
+void drawWifiIcon(int x, int y, bool connected, bool inApMode) {
+  // x,y = angolo in alto a sinistra dell'icona
+  // Disegnamo una piccola "antenna" a 3 archi + punto
+
+  // base
+  mainDisp.drawFrame(x, y, 10, 8);
+
+  // se non connesso, metti una X e basta
+  if (!connected && !inApMode) {
+    mainDisp.drawLine(x+1, y+1, x+8, y+6);
+    mainDisp.drawLine(x+8, y+1, x+1, y+6);
+    return;
+  }
+
+  uint8_t cx = x + 5;
+  uint8_t cy = y + 6;
+
+  // archi (solo 5 parametri)
+  mainDisp.drawArc(cx, cy, 4, 45, 135);  // arco esterno
+  mainDisp.drawArc(cx, cy, 3, 45, 135);  // arco medio
+  mainDisp.drawArc(cx, cy, 2, 45, 135);  // arco interno
+
+  // pallino centrale
+  mainDisp.drawDisc(cx, cy, 1);
+
+  // se sei in AP mode, aggiungi una piccola 'A'
+  if (inApMode) {
+    mainDisp.setFont(u8g2_font_4x6_tr);
+    mainDisp.drawStr(x+1, y+7, "A");
+  }
+}
+
+
+// Disegna la barra superiore con titolo, icona WiFi e orario
+void drawTopBar(const char* title) {
+  mainDisp.setDrawColor(1);
+  mainDisp.setFont(u8g2_font_5x8_tr);
+
+  // sfondo barra
+  mainDisp.drawBox(0, 0, 128, 10);
+  mainDisp.setDrawColor(0);
+  mainDisp.drawHLine(0, 9, 128);
+
+  // titolo a sinistra
+  mainDisp.setCursor(2, 8);
+  mainDisp.print(title);
+
+  // icona wifi + orologio a destra
+  mainDisp.setDrawColor(0);
+  char timeBuf[8];
+  formatTimeString(timeBuf, sizeof(timeBuf));
+
+  int wTime = mainDisp.getStrWidth(timeBuf);
+  int xTime = 126 - wTime;
+  mainDisp.setCursor(xTime, 8);
+  mainDisp.print(timeBuf);
+
+  // icona wifi prima dell'ora
+  int xWifi = xTime - 14;
+  drawWifiIcon(xWifi, 1, wifiConnected, apMode);
+
+  mainDisp.setDrawColor(1);
+}
+
+// =============================
+//  POMPA GRAFICA (piccola animazione)
+// =============================
+
+void drawPumpIcon(int centerX, int centerY, bool on) {
+  static uint8_t frame = 0;
+  static unsigned long lastFrame = 0;
+
+  unsigned long now = millis();
+  if (on && now - lastFrame > 150) {
+    frame = (frame + 1) & 0x03;
+    lastFrame = now;
+  }
+  if (!on) frame = 0;
+
+  int r = 8;
+  mainDisp.drawCircle(centerX, centerY, r);
+  mainDisp.drawCircle(centerX, centerY, r - 2);
+
+  switch (frame) {
+    case 0:
+      mainDisp.drawLine(centerX, centerY, centerX,       centerY - 5);
+      mainDisp.drawLine(centerX, centerY, centerX + 4,   centerY + 2);
+      mainDisp.drawLine(centerX, centerY, centerX - 4,   centerY + 2);
+      break;
+    case 1:
+      mainDisp.drawLine(centerX, centerY, centerX + 4,   centerY - 4);
+      mainDisp.drawLine(centerX, centerY, centerX + 4,   centerY + 4);
+      mainDisp.drawLine(centerX, centerY, centerX - 5,   centerY);
+      break;
+    case 2:
+      mainDisp.drawLine(centerX, centerY, centerX,       centerY + 5);
+      mainDisp.drawLine(centerX, centerY, centerX + 4,   centerY - 2);
+      mainDisp.drawLine(centerX, centerY, centerX - 4,   centerY - 2);
+      break;
+    case 3:
+      mainDisp.drawLine(centerX, centerY, centerX - 4,   centerY - 4);
+      mainDisp.drawLine(centerX, centerY, centerX - 4,   centerY + 4);
+      mainDisp.drawLine(centerX, centerY, centerX + 5,   centerY);
+      break;
+  }
+
+  if (on) {
+    // piccolo simbolo "play" sopra
+    int fx = centerX - 3;
+    int fy = centerY - 11;
+    mainDisp.drawLine(fx,   fy,   fx,   fy+6);
+    mainDisp.drawLine(fx,   fy,   fx+5, fy+3);
+    mainDisp.drawLine(fx+5, fy+3, fx,   fy+6);
+  }
+}
+
+// =============================
+//  HOPPER BAR
+// =============================
+
+void drawHopperBar(int x, int yBottom, int height) {
+  int width = 10;
+
+  mainDisp.drawFrame(x, yBottom - height, width, height);
+
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    int level = (int)((hopper.percent / 100.0f) * (height - 2));
+    if (level < 0) level = 0;
+    if (level > height - 2) level = height - 2;
+    mainDisp.drawBox(x+1, yBottom - 1 - level, width-2, level);
+  } else {
+    // N/A: piccole diagonali dentro il serbatoio
+    for (int yy = yBottom - height + 1; yy < yBottom; yy += 3) {
+      mainDisp.drawLine(x+1, yy, x+width-2, yy+3);
+    }
+  }
+
+  // scritta sotto
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  char buf[10];
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    snprintf(buf, sizeof(buf), "%d%%", (int)(hopper.percent+0.5f));
+  } else {
+    snprintf(buf, sizeof(buf), "N/A");
+  }
+  int w = mainDisp.getStrWidth(buf);
+  int cx = x + (width - w) / 2;
+  mainDisp.drawStr(cx, yBottom + 6, buf);
+}
+
+// =============================
+//  PUFFER GRAFICI
+// =============================
+
+// Disegna un puffer "bicolore" (parte alta calda, parte bassa fredda)
+// In monocromatico usiamo righe differenti sopra/sotto
+void drawPufferTank(int x, int yBottom, int width, int height,
+                    float tMax, float tMin) {
+  // contorno
+  mainDisp.drawFrame(x, yBottom - height, width, height);
+
+  // livello interno (usiamo tMax come livello caldo)
+  int level = mapTempToLevel(tMax, height-2);
+  int hotHeight = level;
+  if (hotHeight < 0) hotHeight = 0;
+  if (hotHeight > height-2) hotHeight = height-2;
+
+  // parte "calda" (sopra) - pattern fitto
+  if (!isnan(tMax)) {
+    int yHotTop = yBottom - 1 - hotHeight;
+    for (int yy = yHotTop; yy < yBottom-1; yy++) {
+      if ((yy & 1) == 0) {
+        mainDisp.drawHLine(x+1, yy, width-2);
+      }
+    }
+  }
+
+  // parte "fredda" (sotto) - pattern più rado (se c'è tMin)
+  if (!isnan(tMin)) {
+    int coldHeight = mapTempToLevel(tMin, height-2);
+    if (coldHeight < 0) coldHeight = 0;
+    if (coldHeight > height-2) coldHeight = height-2;
+    int yColdBottom = yBottom-1;
+    int yColdTop    = yColdBottom - coldHeight;
+    for (int yy = yColdTop; yy <= yColdBottom; yy+=2) {
+      mainDisp.drawHLine(x+1, yy, width-2);
+    }
+  }
+
+  // indicatore livello hot (linea orizzontale)
+  if (!isnan(tMax)) {
+    int yLine = yBottom - 1 - hotHeight;
+    mainDisp.drawHLine(x+1, yLine, width-2);
+  }
+}
+
+// =============================
+//  TEMA 1: CLASSIC
+// =============================
+
+void drawDashboardClassic() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Dashboard", "Dashboard"));
+
+  // Area utile: da y=10 in giù
+  int yBase   = 56;
+  int tankH   = 36;
+  int tankW   = 20;
+  int p1X     = 8;
+  int p2X     = 40;
+
+  // Puffer 1
+  drawPufferTank(p1X, yBase, tankW, tankH, puffer1.tMax, puffer1.tMin);
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  mainDisp.drawStr(p1X+4, yBase - tankH - 2, "P1");
+  char buf[16];
+  if (!isnan(puffer1.tMax)) {
+    snprintf(buf, sizeof(buf), "%.1fC", puffer1.tMax);
+  } else {
+    snprintf(buf, sizeof(buf), "N/A");
+  }
+  mainDisp.drawStr(p1X, yBase + 6, buf);
+
+  // Puffer 2
+  drawPufferTank(p2X, yBase, tankW, tankH, puffer2.tMax, puffer2.tMin);
+  mainDisp.drawStr(p2X+4, yBase - tankH - 2, "P2");
+  if (!isnan(puffer2.tMax)) {
+    snprintf(buf, sizeof(buf), "%.1fC", puffer2.tMax);
+  } else {
+    snprintf(buf, sizeof(buf), "N/A");
+  }
+  mainDisp.drawStr(p2X, yBase + 6, buf);
+
+  // Hopper sul lato destro
+  drawHopperBar(100, yBase, 32);
+
+  // Pompa al centro in basso
+  drawPumpIcon(72, 40, pumpRelayState);
+
+  // Stato pompa
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  snprintf(buf, sizeof(buf), "Pompa: %s", pumpRelayState ? "ON" : "OFF");
+  mainDisp.drawStr(60, 62, buf);
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  TEMA 2: TECHNO (layout più aggressivo)
+// =============================
+
+void drawDashboardTechno() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("DASH:TECH", "DASH:TECH"));
+
+  int yBase = 56;
+  int tankH = 30;
+  int tankW = 16;
+
+  // barre verticali stilizzate per P1 e P2
+  int p1X = 6;
+  int p2X = 30;
+
+  drawPufferTank(p1X, yBase, tankW, tankH, puffer1.tMax, puffer1.tMin);
+  drawPufferTank(p2X, yBase, tankW, tankH, puffer2.tMax, puffer2.tMin);
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(p1X+3, yBase - tankH - 2, "P1");
+  mainDisp.drawStr(p2X+3, yBase - tankH - 2, "P2");
+
+  char buf[16];
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  if (!isnan(puffer1.tMax)) {
+    snprintf(buf, sizeof(buf), "%.1f", puffer1.tMax);
+  } else {
+    snprintf(buf, sizeof(buf), "--.-");
+  }
+  mainDisp.drawStr(p1X-1, yBase + 6, buf);
+
+  if (!isnan(puffer2.tMax)) {
+    snprintf(buf, sizeof(buf), "%.1f", puffer2.tMax);
+  } else {
+    snprintf(buf, sizeof(buf), "--.-");
+  }
+  mainDisp.drawStr(p2X-1, yBase + 6, buf);
+
+  // Hopper come barra più alta e stretta
+  drawHopperBar(100, yBase, 40);
+
+  // tubi stilizzati verso pompa
+  mainDisp.drawLine(p1X + tankW, yBase-10, 60, yBase-10);
+  mainDisp.drawLine(p2X + tankW, yBase-20, 60, yBase-20);
+  mainDisp.drawLine(60, yBase-10, 72, 40);
+  mainDisp.drawLine(60, yBase-20, 72, 40);
+
+  drawPumpIcon(72, 40, pumpRelayState);
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  snprintf(buf, sizeof(buf), "MODE:%s", pumpModeToString());
+  mainDisp.drawStr(52, 52, buf);
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  TEMA 3: DARK LINES (molto minimale)
+// =============================
+
+void drawDashboardDarkLines() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Dashboard", "Dashboard"));
+
+  int yBase = 54;
+  int tankH = 28;
+  int tankW = 14;
+
+  int p1X = 10;
+  int p2X = 36;
+
+  // contorni sottili, niente pattern, solo linee livello
+  mainDisp.drawFrame(p1X, yBase - tankH, tankW, tankH);
+  mainDisp.drawFrame(p2X, yBase - tankH, tankW, tankH);
+
+  int level1 = mapTempToLevel(puffer1.tMax, tankH-2);
+  int level2 = mapTempToLevel(puffer2.tMax, tankH-2);
+
+  if (!isnan(puffer1.tMax)) {
+    int yLine1 = yBase - 1 - level1;
+    mainDisp.drawHLine(p1X+1, yLine1, tankW-2);
+  }
+  if (!isnan(puffer2.tMax)) {
+    int yLine2 = yBase - 1 - level2;
+    mainDisp.drawHLine(p2X+1, yLine2, tankW-2);
+  }
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(p1X+3, yBase - tankH - 2, "P1");
+  mainDisp.drawStr(p2X+3, yBase - tankH - 2, "P2");
+
+  char buf[16];
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  if (!isnan(puffer1.tMax)) snprintf(buf, sizeof(buf), "%.1f", puffer1.tMax); else snprintf(buf, sizeof(buf), "--.-");
+  mainDisp.drawStr(p1X-1, yBase + 6, buf);
+  if (!isnan(puffer2.tMax)) snprintf(buf, sizeof(buf), "%.1f", puffer2.tMax); else snprintf(buf, sizeof(buf), "--.-");
+  mainDisp.drawStr(p2X-1, yBase + 6, buf);
+
+  // Hopper lineare, solo contorno + livello
+  int hopX = 100;
+  int hopH = 32;
+  mainDisp.drawFrame(hopX, yBase - hopH, 10, hopH);
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    int level = (int)((hopper.percent / 100.0f) * (hopH-2));
+    if (level < 0) level = 0;
+    if (level > hopH-2) level = hopH-2;
+    int yLine = yBase - 1 - level;
+    mainDisp.drawHLine(hopX+1, yLine, 8);
+  }
+
+  // Piccola indicazione pompa in testo
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  snprintf(buf, sizeof(buf), "P:%s", pumpRelayState ? "ON" : "OFF");
+  mainDisp.drawStr(60, 54, buf);
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  TEMA 4: WAVE FLOW (enfasi sui tubi / flussi)
+// =============================
+
+void drawDashboardWaveFlow() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Flow View", "Flow View"));
+
+  int yBase = 56;
+  int tankH = 32;
+  int tankW = 18;
+
+  int p1X = 6;
+  int p2X = 38;
+
+  drawPufferTank(p1X, yBase, tankW, tankH, puffer1.tMax, puffer1.tMin);
+  drawPufferTank(p2X, yBase, tankW, tankH, puffer2.tMax, puffer2.tMin);
+
+  // tubi ondulati da P2 verso P1 e da caldaia (immaginaria) verso P1
+  for (int i = 0; i < 3; i++) {
+    int y1 = yBase - 10 - i;
+    int y2 = yBase - 20 - i;
+    // onda
+    mainDisp.drawLine(p2X + tankW, y2, p1X - 2, y2);
+    if ((i & 1) == 0) {
+      for (int xx = p2X + tankW; xx < p1X - 2; xx+=4) {
+        mainDisp.drawPixel(xx, y2-1);
+      }
+    }
+    mainDisp.drawLine(p1X + tankW, y1, 80, y1);
+  }
+
+  // Hopper come silo più alto
+  drawHopperBar(100, yBase, 38);
+
+  // Pompa sul ritorno in basso
+  drawPumpIcon(72, 44, pumpRelayState);
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  char buf[20];
+  snprintf(buf, sizeof(buf), "Set:%.1fC", pumpSetTemp);
+  mainDisp.drawStr(60, 54, buf);
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  TEMA 5: CHRISTMAS (natalizio)
+// =============================
+
+void drawDashboardChristmas() {
+  static bool snowInit = false;
+  static int snowX[16];
+  static int snowY[16];
+  static unsigned long lastSnowUpdate = 0;
+
+  if (!snowInit) {
+    for (int i = 0; i < 16; i++) {
+      snowX[i] = random(0, 128);
+      snowY[i] = random(10, 64);
+    }
+    snowInit = true;
+  }
+
+  unsigned long now = millis();
+  if (now - lastSnowUpdate > 150) {
+    lastSnowUpdate = now;
+    for (int i = 0; i < 16; i++) {
+      snowY[i] += 1 + (i % 2);
+      if (snowY[i] > 64) {
+        snowY[i] = 10;
+        snowX[i] = random(0, 128);
+      }
+    }
+  }
+
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Natale", "Christmas"));
+
+  int yBase = 56;
+  int tankH = 32;
+  int tankW = 16;
+
+  int p1X = 10;
+  int p2X = 36;
+
+  // Puffer come "candele"
+  drawPufferTank(p1X, yBase, tankW, tankH, puffer1.tMax, puffer1.tMin);
+  drawPufferTank(p2X, yBase, tankW, tankH, puffer2.tMax, puffer2.tMin);
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(p1X+3, yBase - tankH - 3, "P1");
+  mainDisp.drawStr(p2X+3, yBase - tankH - 3, "P2");
+
+  // Piccole "fiamme" sopra i puffer
+  mainDisp.drawTriangle(p1X+8, yBase - tankH - 4, p1X+5, yBase - tankH, p1X+11, yBase - tankH);
+  mainDisp.drawTriangle(p2X+8, yBase - tankH - 4, p2X+5, yBase - tankH, p2X+11, yBase - tankH);
+
+  // Hopper come sacco dei regali
+  int hopX = 96;
+  int hopY = yBase;
+  mainDisp.drawFrame(hopX, hopY - 22, 16, 22);
+  mainDisp.drawLine(hopX, hopY - 18, hopX+15, hopY - 20);
+  // contenuto
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    int fillH = (int)((hopper.percent/100.0f) * 18);
+    if (fillH < 0) fillH = 0;
+    if (fillH > 18) fillH = 18;
+    mainDisp.drawBox(hopX+1, hopY - 2 - fillH, 14, fillH);
+  } else {
+    for (int yy = hopY-2; yy > hopY-20; yy-=3) {
+      mainDisp.drawHLine(hopX+1, yy, 14);
+    }
+  }
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  char buf[16];
+  if (!isnan(puffer1.tMax)) snprintf(buf, sizeof(buf), "%.1fC", puffer1.tMax); else snprintf(buf, sizeof(buf), "N/A");
+  mainDisp.drawStr(4, 60, buf);
+  if (!isnan(puffer2.tMax)) snprintf(buf, sizeof(buf), "%.1fC", puffer2.tMax); else snprintf(buf, sizeof(buf), "N/A");
+  mainDisp.drawStr(40, 60, buf);
+
+  // Neve animata
+  for (int i = 0; i < 16; i++) {
+    mainDisp.drawPixel(snowX[i], snowY[i]);
+  }
+
+  // Pompa con cappellino di Natale
+  drawPumpIcon(72, 40, pumpRelayState);
+  // cappellino
+  mainDisp.drawTriangle(68, 30, 76, 30, 72, 24);
+  mainDisp.drawDisc(72, 23, 1);
+
+  // Stellina lampeggiante
+  if (((now / 500) % 2) == 0) {
+    mainDisp.drawPixel(120, 14);
+    mainDisp.drawPixel(121, 15);
+    mainDisp.drawPixel(122, 14);
+  }
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  DISPATCHER GENERALE DASHBOARD
+// =============================
+
+void drawDashboard() {
+  // se è Natale e l'utente non ha cambiato tema manualmente,
+  // potremmo forzare il tema natalizio; per ora usiamo solo
+  // l'autoSelectChristmasThemeIfNeeded() in setup.
+
+  switch (currentTheme) {
+    case THEME_CLASSIC:    drawDashboardClassic();    break;
+    case THEME_TECHNO:     drawDashboardTechno();     break;
+    case THEME_DARKLINES:  drawDashboardDarkLines();  break;
+    case THEME_WAVE:       drawDashboardWaveFlow();   break;
+    case THEME_CHRISTMAS:  drawDashboardChristmas();  break;
+    default:               drawDashboardClassic();    break;
+  }
+}
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 4: Menu + schermate impostazioni + handler UI
+// =========================================================
+
+// =============================
+//  MENU PRINCIPALE
+// =============================
+
+enum MenuId {
+  MENU_DASHBOARD = 0,
+  MENU_STATUS,
+  MENU_PUMP,
+  MENU_DISPLAY,
+  MENU_TIME,
+  MENU_SYSTEM,
+  MENU_THEME,
+  MENU_LANGUAGE,
+  MENU_SCREENSAVER,
+  MENU_OTA,
+  MENU_FACTORY_RESET,
+  MENU_DIAG,
+  MENU_INFO,
+  MENU_COUNT
+};
+
+const char* const menuLabels[MENU_COUNT][LANG_COUNT] = {
+  { "Dashboard",     "Dashboard" },
+  { "Stato sistema", "System status" },
+  { "Pompa",         "Pump" },
+  { "Display",       "Display" },
+  { "Orologio",      "Clock" },
+  { "Sistema",       "System" },
+  { "Tema display",  "Display theme" },
+  { "Lingua",        "Language" },
+  { "Salvaschermo",  "Screensaver" },
+  { "Agg. OTA",      "OTA update" },
+  { "Factory reset", "Factory reset" },
+  { "Diagnostica",   "Diagnostics" },
+  { "Info",          "Info" }
+};
+
+struct MenuItem {
+  MenuId      id;
+  UiState     target;
+};
+
+MenuItem mainMenu[] = {
+  { MENU_DASHBOARD,     UI_DASHBOARD },
+  { MENU_STATUS,        UI_STATUS },
+  { MENU_PUMP,          UI_PUMP },
+  { MENU_DISPLAY,       UI_DISPLAY_SETTINGS },
+  { MENU_TIME,          UI_TIME_SETTINGS },
+  { MENU_SYSTEM,        UI_SYSTEM_SETTINGS },
+  { MENU_THEME,         UI_THEME_SELECT },
+  { MENU_LANGUAGE,      UI_LANGUAGE_SELECT },
+  { MENU_SCREENSAVER,   UI_SCREENSAVER_SETTINGS },
+  { MENU_OTA,           UI_OTA_UPDATE },
+  { MENU_FACTORY_RESET, UI_FACTORY_RESET },
+  { MENU_DIAG,          UI_DIAG },
+  { MENU_INFO,          UI_INFO }
+};
+
+const int MENU_ITEMS   = sizeof(mainMenu) / sizeof(mainMenu[0]);
+int       menuIndex    = 0;
+int       menuTopIndex = 0;
+const int MENU_VISIBLE = 4;
+
+// =============================
+//  STATO SCREEN
+// =============================
+
+int statusTopLine = 0;
+
+void drawStatusScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Stato", "Status"));
+
+  char upBuf[32];
+  formatUptime(upBuf, sizeof(upBuf));
+  float vcc = getVcc();
+
+  String lines[12];
+  int totalLines = 0;
+  char buf[40];
+
+  // P1
+  if (!isnan(puffer1.tMax)) snprintf(buf, sizeof(buf), "P1 Tmax: %.1fC", puffer1.tMax);
+  else snprintf(buf, sizeof(buf), "P1 Tmax: N/A");
+  lines[totalLines++] = String(buf);
+
+  if (!isnan(puffer1.tMin)) snprintf(buf, sizeof(buf), "P1 Tmin: %.1fC", puffer1.tMin);
+  else snprintf(buf, sizeof(buf), "P1 Tmin: N/A");
+  lines[totalLines++] = String(buf);
+
+  // P2
+  if (!isnan(puffer2.tMax)) snprintf(buf, sizeof(buf), "P2 Tmax: %.1fC", puffer2.tMax);
+  else snprintf(buf, sizeof(buf), "P2 Tmax: N/A");
+  lines[totalLines++] = String(buf);
+
+  if (!isnan(puffer2.tMin)) snprintf(buf, sizeof(buf), "P2 Tmin: %.1fC", puffer2.tMin);
+  else snprintf(buf, sizeof(buf), "P2 Tmin: N/A");
+  lines[totalLines++] = String(buf);
+
+  // Pompa
+  snprintf(buf, sizeof(buf), "Pompa: %s (%s)",
+           pumpRelayState ? "ON" : "OFF",
+           pumpModeToString());
+  lines[totalLines++] = String(buf);
+
+  snprintf(buf, sizeof(buf), "Set pompa: %.1fC", pumpSetTemp);
+  lines[totalLines++] = String(buf);
+
+  // Hopper
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    snprintf(buf, sizeof(buf), "Hopper: %.0f%%", hopper.percent);
+  } else {
+    snprintf(buf, sizeof(buf), "Hopper: N/A");
+  }
+  lines[totalLines++] = String(buf);
+
+  // VCC & alimentazione
+  snprintf(buf, sizeof(buf), "VCC MCU: %.2fV", vcc);
+  lines[totalLines++] = String(buf);
+  snprintf(buf, sizeof(buf), "Vcc 5V: %.2fV", supplyVoltage5V);
+  lines[totalLines++] = String(buf);
+
+  // WiFi
+  String wifiLine = "WiFi: ";
+  if (wifiConnected) {
+    wifiLine += "OK ";
+    wifiLine += WiFi.SSID();
+  } else if (apMode) {
+    wifiLine += "AP only";
+  } else {
+    wifiLine += "NO";
+  }
+  lines[totalLines++] = wifiLine;
+
+  // Uptime
+  lines[totalLines++] = String("Uptime: ") + String(upBuf);
+
+  const int VIS_LINES = 5;
+  if (statusTopLine < 0) statusTopLine = 0;
+  if (statusTopLine > totalLines - VIS_LINES) {
+    statusTopLine = max(0, totalLines - VIS_LINES);
+  }
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  for (int i = 0; i < VIS_LINES; i++) {
+    int idx = statusTopLine + i;
+    if (idx >= totalLines) break;
+    int y = 20 + i * 10;
+    mainDisp.setCursor(0, y);
+    mainDisp.print(lines[idx]);
+  }
+
+  mainDisp.sendBuffer();
+}
+
+// =============================
+//  POMPA SCREEN (modo + setpoint)
+// =============================
+
+int  pumpScreenIndex = 0;    // 0=Modo, 1=Setpoint, 2=Back
+bool pumpEditSetpoint = false;
+
+void drawPumpScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Pompa", "Pump"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, "Controllo Pompa");
+
+  int yBase = 30;
+  char buf[32];
+
+  // Riga 0: Modo
+  int y0 = yBase;
+  if (pumpScreenIndex == 0 && !pumpEditSetpoint) {
+    mainDisp.drawBox(0, y0-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y0);
+  mainDisp.print("Modo: ");
+  mainDisp.print(pumpModeToString());
+  if (pumpScreenIndex == 0 && !pumpEditSetpoint) mainDisp.setDrawColor(1);
+
+  // Riga 1: Setpoint
+  int y1 = yBase + 12;
+  if (pumpScreenIndex == 1) {
+    mainDisp.drawBox(0, y1-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y1);
+  if (pumpEditSetpoint) {
+    snprintf(buf, sizeof(buf), "Set: [%.1fC]", pumpSetTemp);
+  } else {
+    snprintf(buf, sizeof(buf), "Set: %.1fC", pumpSetTemp);
+  }
+  mainDisp.print(buf);
+  if (pumpScreenIndex == 1) mainDisp.setDrawColor(1);
+
+  // Riga 2: Back
+  int y2 = yBase + 24;
+  if (pumpScreenIndex == 2) {
+    mainDisp.drawBox(0, y2-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y2);
+  mainDisp.print("Indietro");
+  if (pumpScreenIndex == 2) mainDisp.setDrawColor(1);
+
+  // Stato pompa in basso
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  snprintf(buf, sizeof(buf), "Stato: %s", pumpRelayState ? "ON" : "OFF");
+  mainDisp.drawStr(2, 62, buf);
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiPump() {
+  if (!pumpEditSetpoint) {
+    if (upPressed) {
+      pumpScreenIndex--;
+      if (pumpScreenIndex < 0) pumpScreenIndex = 2;
+    }
+    if (downPressed) {
+      pumpScreenIndex++;
+      if (pumpScreenIndex > 2) pumpScreenIndex = 0;
+    }
+
+    if (selectPressed) {
+      if (pumpScreenIndex == 0) {
+        // cambia modo
+        if (pumpMode == PUMP_AUTO) pumpMode = PUMP_FORCE_ON;
+        else if (pumpMode == PUMP_FORCE_ON) pumpMode = PUMP_FORCE_OFF;
+        else pumpMode = PUMP_AUTO;
+      } else if (pumpScreenIndex == 1) {
+        // entra in edit setpoint
+        pumpEditSetpoint = true;
+      } else if (pumpScreenIndex == 2) {
+        // back
+        savePumpConfig();
+        uiState = UI_MENU;
+      }
+    }
+  } else {
+    // in edit setpoint
+    if (upPressed) {
+      pumpSetTemp += 0.5f;
+      if (pumpSetTemp > 90.0f) pumpSetTemp = 90.0f;
+    }
+    if (downPressed) {
+      pumpSetTemp -= 0.5f;
+      if (pumpSetTemp < 10.0f) pumpSetTemp = 10.0f;
+    }
+    if (selectPressed) {
+      // esce dall'edit e salva
+      pumpEditSetpoint = false;
+      savePumpConfig();
+    }
+  }
+
+  drawPumpScreen();
+}
+
+// =============================
+//  DISPLAY SETTINGS SCREEN
+// =============================
+
+void drawDisplaySettingsScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Display", "Display"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, "Impostazioni Display");
+
+  mainDisp.setCursor(0, 34);
+  mainDisp.print("Flip: ");
+  mainDisp.print(mainFlip ? "Capovolto" : "Normale");
+
+  mainDisp.setCursor(0, 48);
+  mainDisp.print("Contrasto: ");
+  mainDisp.print(mainContrast);
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(0, 62, "UP/DOWN=Contrasto, OK=Flip, OK lungo=Indietro");
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiDisplaySettings() {
+  if (upPressed) {
+    if (mainContrast < 255 - 8) mainContrast += 8;
+    else mainContrast = 255;
+    mainDisp.setContrast(mainContrast);
+    saveDisplayConfig();
+  }
+  if (downPressed) {
+    if (mainContrast > 8) mainContrast -= 8;
+    else mainContrast = 0;
+    mainDisp.setContrast(mainContrast);
+    saveDisplayConfig();
+  }
+
+  static bool selPrev = false;
+  static unsigned long selStart = 0;
+  bool selNow = (digitalRead(PIN_BTN_SELECT) == LOW);
+  unsigned long now = millis();
+
+  if (selNow && !selPrev) {
+    selStart = now;
+  }
+  if (!selNow && selPrev) {
+    unsigned long dur = now - selStart;
+    if (dur >= LONG_PRESS_MS) {
+      uiState = UI_MENU;
+    } else {
+      mainFlip = mainFlip ? 0 : 1;
+      mainDisp.setFlipMode(mainFlip);
+      saveDisplayConfig();
+    }
+  }
+  selPrev = selNow;
+
+  drawDisplaySettingsScreen();
+}
+
+// =============================
+//  TIME SETTINGS SCREEN
+// =============================
+
+int timeScreenIndex = 0;  // 0=NTP, 1=Fuso, 2=Formato, 3=Indietro
+
+void drawTimeSettingsScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Orologio", "Clock"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, "Impostazioni Orologio");
+
+  int yBase = 32;
+
+  int y0 = yBase;
+  if (timeScreenIndex == 0) {
+    mainDisp.drawBox(0, y0-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y0);
+  mainDisp.print("Internet time: ");
+  mainDisp.print(clockUseNtp ? "SI" : "NO");
+  if (timeScreenIndex == 0) mainDisp.setDrawColor(1);
+
+  int y1 = yBase + 12;
+  if (timeScreenIndex == 1) {
+    mainDisp.drawBox(0, y1-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y1);
+  mainDisp.print("Fuso: ");
+  mainDisp.print(TIMEZONES[clockTzIndex].city);
+  if (timeScreenIndex == 1) mainDisp.setDrawColor(1);
+
+  int y2 = yBase + 24;
+  if (timeScreenIndex == 2) {
+    mainDisp.drawBox(0, y2-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y2);
+  mainDisp.print("Formato: ");
+  mainDisp.print(clockIs24h ? "24h" : "12h");
+  if (timeScreenIndex == 2) mainDisp.setDrawColor(1);
+
+  int y3 = yBase + 36;
+  if (timeScreenIndex == 3) {
+    mainDisp.drawBox(0, y3-8, 128, 10);
+    mainDisp.setDrawColor(0);
+  }
+  mainDisp.setCursor(2, y3);
+  mainDisp.print("Indietro");
+  if (timeScreenIndex == 3) mainDisp.setDrawColor(1);
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiTimeSettings() {
+  if (upPressed) {
+    timeScreenIndex--;
+    if (timeScreenIndex < 0) timeScreenIndex = 3;
+  }
+  if (downPressed) {
+    timeScreenIndex++;
+    if (timeScreenIndex > 3) timeScreenIndex = 0;
+  }
+
+  if (selectPressed) {
+    if (timeScreenIndex == 0) {
+      clockUseNtp = !clockUseNtp;
+      saveGlobalConfig();
+      setupTimeConfig();
+    } else if (timeScreenIndex == 1) {
+      clockTzIndex++;
+      if (clockTzIndex >= TIMEZONES_COUNT) clockTzIndex = 0;
+      saveGlobalConfig();
+      setupTimeConfig();
+    } else if (timeScreenIndex == 2) {
+      clockIs24h = !clockIs24h;
+      saveGlobalConfig();
+    } else if (timeScreenIndex == 3) {
+      uiState = UI_MENU;
+    }
+  }
+
+  drawTimeSettingsScreen();
+}
+
+// =============================
+//  SYSTEM SETTINGS SCREEN
+// =============================
+// voci: AUX, Puffer1, Puffer2, Sonda1..4, Indietro
+
+int systemScreenIndex = 0; // 0=AUX, 1=P1, 2=P2, 3=Sp1,4=Sp2,5=Sp3,6=Sp4,7=Indietro
+int systemTopIndex = 0;
+const int SYSTEM_VISIBLE = 4;
+
+void drawSystemSettingsScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Sistema", "System"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, tr("Impostazioni Sistema", "System settings"));
+
+  const int systemTotal = 8;
+  int yBase = 30;
+  for (int i = 0; i < SYSTEM_VISIBLE; i++) {
+    int idx = systemTopIndex + i;
+    if (idx >= systemTotal) break;
+    int y = yBase + i * 10;
+    if (systemScreenIndex == idx) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+    }
+    mainDisp.setCursor(2, y);
+    switch (idx) {
+      case 0:
+        mainDisp.print("AUX rele");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(auxRelayState ? "ON" : "OFF");
+        break;
+      case 1:
+        mainDisp.print("Puffer 1");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(puffer1.enabled ? "ON" : "OFF");
+        break;
+      case 2:
+        mainDisp.print("Puffer 2");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(puffer2.enabled ? "ON" : "OFF");
+        break;
+      case 3:
+        mainDisp.print("Sonda P1 MAX");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(sonde[SONDA_P1_MAX].enabled ? "ON" : "OFF");
+        break;
+      case 4:
+        mainDisp.print("Sonda P1 MIN");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(sonde[SONDA_P1_MIN].enabled ? "ON" : "OFF");
+        break;
+      case 5:
+        mainDisp.print("Sonda P2 MAX");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(sonde[SONDA_P2_MAX].enabled ? "ON" : "OFF");
+        break;
+      case 6:
+        mainDisp.print("Sonda P2 MIN");
+        mainDisp.setCursor(100, y);
+        mainDisp.print(sonde[SONDA_P2_MIN].enabled ? "ON" : "OFF");
+        break;
+      case 7:
+        mainDisp.print(tr("Indietro", "Back"));
+        break;
+    }
+    if (systemScreenIndex == idx) mainDisp.setDrawColor(1);
+  }
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiSystemSettings() {
+  if (upPressed) {
+    systemScreenIndex--;
+    if (systemScreenIndex < 0) systemScreenIndex = 7;
+  }
+  if (downPressed) {
+    systemScreenIndex++;
+    if (systemScreenIndex > 7) systemScreenIndex = 0;
+  }
+
+  if (systemScreenIndex < systemTopIndex) {
+    systemTopIndex = systemScreenIndex;
+  }
+  if (systemScreenIndex >= systemTopIndex + SYSTEM_VISIBLE) {
+    systemTopIndex = systemScreenIndex - SYSTEM_VISIBLE + 1;
+  }
+
+  if (selectPressed) {
+    switch (systemScreenIndex) {
+      case 0:
+        auxRelayState = !auxRelayState;
+        applyAuxRelay(auxRelayState);
+        saveGlobalConfig();
+        break;
+      case 1:
+        puffer1.enabled = !puffer1.enabled;
+        saveGlobalConfig();
+        break;
+      case 2:
+        puffer2.enabled = !puffer2.enabled;
+        saveGlobalConfig();
+        break;
+      case 3:
+        sonde[SONDA_P1_MAX].enabled = !sonde[SONDA_P1_MAX].enabled;
+        saveGlobalConfig();
+        break;
+      case 4:
+        sonde[SONDA_P1_MIN].enabled = !sonde[SONDA_P1_MIN].enabled;
+        saveGlobalConfig();
+        break;
+      case 5:
+        sonde[SONDA_P2_MAX].enabled = !sonde[SONDA_P2_MAX].enabled;
+        saveGlobalConfig();
+        break;
+      case 6:
+        sonde[SONDA_P2_MIN].enabled = !sonde[SONDA_P2_MIN].enabled;
+        saveGlobalConfig();
+        break;
+      case 7:
+        uiState = UI_MENU;
+        break;
+    }
+  }
+
+  drawSystemSettingsScreen();
+}
+
+// =============================
+//  THEME SELECT SCREEN
+// =============================
+
+int themeScreenIndex = 0;
+int themeTopIndex = 0;
+const int THEME_VISIBLE = 3;
+
+void drawThemeSelectScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Tema", "Theme"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, tr("Seleziona tema", "Select theme"));
+
+  int yBase = 30;
+
+  for (int i = 0; i < THEME_VISIBLE; i++) {
+    int idx = themeTopIndex + i;
+    if (idx >= THEME_COUNT) break;
+    int y = yBase + i*10;
+    if (themeScreenIndex == idx) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+    }
+    mainDisp.setCursor(2, y);
+    if (idx == currentTheme) mainDisp.print("* ");
+    else                     mainDisp.print("  ");
+    mainDisp.print(THEMES[idx].name);
+    if (themeScreenIndex == idx) mainDisp.setDrawColor(1);
+  }
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(0, 62, tr("OK=Seleziona, OK lungo=Indietro", "OK=Select, Hold OK=Back"));
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiThemeSelect() {
+  if (upPressed) {
+    themeScreenIndex--;
+    if (themeScreenIndex < 0) themeScreenIndex = THEME_COUNT-1;
+  }
+  if (downPressed) {
+    themeScreenIndex++;
+    if (themeScreenIndex >= THEME_COUNT) themeScreenIndex = 0;
+  }
+
+  if (themeScreenIndex < themeTopIndex) {
+    themeTopIndex = themeScreenIndex;
+  }
+  if (themeScreenIndex >= themeTopIndex + THEME_VISIBLE) {
+    themeTopIndex = themeScreenIndex - THEME_VISIBLE + 1;
+  }
+
+  static bool selPrev = false;
+  static unsigned long selStart = 0;
+  bool selNow = (digitalRead(PIN_BTN_SELECT) == LOW);
+  unsigned long now = millis();
+
+  if (selNow && !selPrev) {
+    selStart = now;
+  }
+  if (!selNow && selPrev) {
+    unsigned long dur = now - selStart;
+    if (dur >= LONG_PRESS_MS) {
+      uiState = UI_MENU;
+    } else {
+      currentTheme = (ThemeId)themeScreenIndex;
+      saveGlobalConfig();
+    }
+  }
+  selPrev = selNow;
+
+  drawThemeSelectScreen();
+}
+
+// =============================
+//  LANGUAGE SELECT SCREEN
+// =============================
+
+int languageScreenIndex = 0;
+
+void drawLanguageSelectScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Lingua", "Language"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, tr("Seleziona lingua", "Select language"));
+
+  int yBase = 32;
+
+  for (int i = 0; i < LANG_COUNT; i++) {
+    int y = yBase + i*10;
+    if (languageScreenIndex == i) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+    }
+    mainDisp.setCursor(2, y);
+    if (i == currentLanguage) mainDisp.print("* ");
+    else                      mainDisp.print("  ");
+    mainDisp.print(languageName((LanguageId)i));
+    if (languageScreenIndex == i) mainDisp.setDrawColor(1);
+  }
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(0, 62, tr("OK=Seleziona, OK lungo=Indietro", "OK=Select, Hold OK=Back"));
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiLanguageSelect() {
+  if (upPressed) {
+    languageScreenIndex--;
+    if (languageScreenIndex < 0) languageScreenIndex = LANG_COUNT-1;
+  }
+  if (downPressed) {
+    languageScreenIndex++;
+    if (languageScreenIndex >= LANG_COUNT) languageScreenIndex = 0;
+  }
+
+  static bool selPrev = false;
+  static unsigned long selStart = 0;
+  bool selNow = (digitalRead(PIN_BTN_SELECT) == LOW);
+  unsigned long now = millis();
+
+  if (selNow && !selPrev) {
+    selStart = now;
+  }
+  if (!selNow && selPrev) {
+    unsigned long dur = now - selStart;
+    if (dur >= LONG_PRESS_MS) {
+      uiState = UI_MENU;
+    } else {
+      currentLanguage = (LanguageId)languageScreenIndex;
+      saveGlobalConfig();
+    }
+  }
+  selPrev = selNow;
+
+  drawLanguageSelectScreen();
+}
+
+// =============================
+//  SCREENSAVER SETTINGS SCREEN
+// =============================
+
+int screensaverScreenIndex = 0; // 0=Off,1=Anim,2=Display Off
+
+const char* screensaverLabel(int idx) {
+  switch (idx) {
+    case 0: return tr("Nessuno", "None");
+    case 1: return tr("Salvaschermo", "Screensaver");
+    case 2: return tr("Schermo Off", "Display Off");
+    default: return "??";
+  }
+}
+
+void drawScreensaverSettingsScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Salvaschermo", "Screensaver"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 18, tr("Opzioni schermo", "Screen options"));
+
+  int yBase = 32;
+  for (int i = 0; i < 3; i++) {
+    int y = yBase + i * 10;
+    if (screensaverScreenIndex == i) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+    }
+    mainDisp.setCursor(2, y);
+    if ((int)screenSaverMode == i) mainDisp.print("* ");
+    else                           mainDisp.print("  ");
+    mainDisp.print(screensaverLabel(i));
+    if (screensaverScreenIndex == i) mainDisp.setDrawColor(1);
+  }
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  mainDisp.drawStr(0, 62, tr("OK=Seleziona, OK lungo=Indietro",
+                            "OK=Select, Hold OK=Back"));
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiScreensaverSettings() {
+  if (upPressed) {
+    screensaverScreenIndex--;
+    if (screensaverScreenIndex < 0) screensaverScreenIndex = 2;
+  }
+  if (downPressed) {
+    screensaverScreenIndex++;
+    if (screensaverScreenIndex > 2) screensaverScreenIndex = 0;
+  }
+
+  static bool selPrev = false;
+  static unsigned long selStart = 0;
+  bool selNow = (digitalRead(PIN_BTN_SELECT) == LOW);
+  unsigned long now = millis();
+
+  if (selNow && !selPrev) {
+    selStart = now;
+  }
+  if (!selNow && selPrev) {
+    unsigned long dur = now - selStart;
+    if (dur >= LONG_PRESS_MS) {
+      uiState = UI_MENU;
+    } else {
+      screenSaverMode = (ScreenSaverMode)screensaverScreenIndex;
+      saveGlobalConfig();
+    }
+  }
+  selPrev = selNow;
+
+  drawScreensaverSettingsScreen();
+}
+
+// =============================
+//  SCREENSAVER RENDER
+// =============================
+
+void drawScreensaver() {
+  static int x = 10;
+  static int y = 28;
+  static int vx = 2;
+  static int vy = 1;
+  static unsigned long lastAnim = 0;
+  unsigned long now = millis();
+
+  if (now - lastAnim > 120) {
+    lastAnim = now;
+    x += vx;
+    y += vy;
+    if (x < 2 || x > 90) vx = -vx;
+    if (y < 18 || y > 54) vy = -vy;
+  }
+
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Salvaschermo", "Screensaver"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.setCursor(x, y);
+  mainDisp.print("TermoSystem");
+
+  mainDisp.setFont(u8g2_font_4x6_tr);
+  char buf[16];
+  if (!isnan(puffer1.tMax)) snprintf(buf, sizeof(buf), "P1 %.1fC", puffer1.tMax);
+  else snprintf(buf, sizeof(buf), "P1 N/A");
+  mainDisp.drawStr(2, 62, buf);
+  if (!isnan(puffer2.tMax)) snprintf(buf, sizeof(buf), "P2 %.1fC", puffer2.tMax);
+  else snprintf(buf, sizeof(buf), "P2 N/A");
+  mainDisp.drawStr(64, 62, buf);
+
+  mainDisp.sendBuffer();
+}
+
+void updateScreensaverState() {
+  unsigned long now = millis();
+  bool anyPress = upPressed || downPressed || selectPressed;
+
+  if (displaySleeping) {
+    if (anyPress) {
+      displaySleeping = false;
+      uiState = UI_DASHBOARD;
+    }
+    return;
+  }
+
+  if (screenSaverMode == SCREENSAVER_OFF) {
+    if (now - lastUserActivityMs >= SCREENSAVER_TIMEOUT_MS) {
+      mainDisp.setPowerSave(1);
+      displaySleeping = true;
+    }
+    return;
+  }
+
+  if (screenSaverMode == SCREENSAVER_ANIM) {
+    if (now - lastUserActivityMs >= SCREENSAVER_TIMEOUT_MS) {
+      uiState = UI_SCREENSAVER;
+    } else if (uiState == UI_SCREENSAVER && anyPress) {
+      uiState = UI_DASHBOARD;
+    }
+  } else {
+    if (uiState == UI_SCREENSAVER) {
+      uiState = UI_DASHBOARD;
+    }
+  }
+}
+
+// =============================
+//  OTA UPDATE SCREEN
+// =============================
+
+void drawOtaUpdateScreen(const char* statusLine) {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Agg. OTA", "OTA update"));
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 20, tr("Aggiornamento OTA", "OTA update"));
+
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  mainDisp.drawStr(0, 36, statusLine);
+
+  char buf[24];
+  if (otaProgress >= 0) {
+    snprintf(buf, sizeof(buf), "Progress: %d%%", otaProgress);
+    mainDisp.drawStr(0, 50, buf);
+  }
+
+  mainDisp.sendBuffer();
+}
+
+void startOtaUpdate() {
+  if (!wifiConnected) {
+    drawOtaUpdateScreen(tr("WiFi non connesso", "WiFi not connected"));
+    delay(1200);
+    uiState = UI_MENU;
+    return;
+  }
+
+  otaInProgress = true;
+  otaProgress = -1;
+  otaLastError = 0;
+  drawOtaUpdateScreen(tr("Connessione...", "Connecting..."));
+  delay(300);
+
+  WiFiClientSecure client;
+  client.setInsecure();
+
+  ESPhttpUpdate.onProgress([](int cur, int total) {
+    if (total > 0) {
+      otaProgress = (cur * 100) / total;
+    }
+  });
+
+  t_httpUpdate_return ret = ESPhttpUpdate.update(client, OTA_FIRMWARE_URL);
+  if (ret == HTTP_UPDATE_OK) {
+    drawOtaUpdateScreen(tr("Update OK - Riavvio", "Update OK - Reboot"));
+    delay(800);
+  } else {
+    otaLastError = ESPhttpUpdate.getLastError();
+    drawOtaUpdateScreen(tr("Errore OTA", "OTA error"));
+    delay(1200);
+    uiState = UI_MENU;
+  }
+  otaInProgress = false;
+}
+
+void handleUiOtaUpdate() {
+  if (otaStartRequested) {
+    otaStartRequested = false;
+    startOtaUpdate();
+  } else if (!otaInProgress) {
+    if (selectPressed) uiState = UI_MENU;
+    drawOtaUpdateScreen(tr("Premi OK per uscire", "Press OK to exit"));
+  }
+}
+
+// =============================
+//  FACTORY RESET SCREEN
+// =============================
+
+int factoryResetIndex = 0; // 0=Annulla, 1=Conferma
+
+void drawFactoryResetScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Factory reset", "Factory reset"));
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 20, tr("Reset di fabbrica", "Factory reset"));
+
+  int yBase = 36;
+  for (int i = 0; i < 2; i++) {
+    int y = yBase + i * 12;
+    if (factoryResetIndex == i) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+    }
+    mainDisp.setCursor(2, y);
+    if (i == 0) mainDisp.print(tr("Annulla", "Cancel"));
+    else        mainDisp.print(tr("Conferma", "Confirm"));
+    if (factoryResetIndex == i) mainDisp.setDrawColor(1);
+  }
+
+  mainDisp.sendBuffer();
+}
+
+void drawFactoryResetProgress() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Factory reset", "Factory reset"));
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 30, tr("Reset in corso...", "Resetting..."));
+  mainDisp.sendBuffer();
+}
+
+void handleUiFactoryReset() {
+  if (upPressed || downPressed) {
+    factoryResetIndex = 1 - factoryResetIndex;
+  }
+
+  if (selectPressed) {
+    if (factoryResetIndex == 0) {
+      uiState = UI_MENU;
+    } else {
+      drawFactoryResetProgress();
+      resetFactoryDefaults();
+      delay(800);
+      ESP.restart();
+    }
+  }
+
+  drawFactoryResetScreen();
+}
+
+// =============================
+//  DIAGNOSTICA & INFO RUNTIME
+// =============================
+
+void drawDiagScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Diagnostica", "Diagnostics"));
+
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  int y = 18;
+
+  auto line = [&](const char* lbl, bool ok) {
+    mainDisp.setCursor(0, y);
+    mainDisp.print(lbl);
+    mainDisp.setCursor(90, y);
+    mainDisp.print(ok ? "OK" : "N/A");
+    y += 8;
+  };
+
+  line("P1 MAX", sonde[SONDA_P1_MAX].ok);
+  line("P1 MIN", sonde[SONDA_P1_MIN].ok);
+  line("P2 MAX", sonde[SONDA_P2_MAX].ok);
+  line("P2 MIN", sonde[SONDA_P2_MIN].ok);
+  line("WiFi",   wifiConnected);
+  line("AP",     apMode);
+
+  float vcc = getVcc();
+  mainDisp.setCursor(0, y+4);
+  char buf[32];
+  snprintf(buf, sizeof(buf), "VCC MCU: %.2fV", vcc);
+  mainDisp.print(buf);
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiDiag() {
+  if (selectPressed) uiState = UI_MENU;
+  drawDiagScreen();
+}
+
+void drawInfoScreen() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Info", "Info"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+  mainDisp.drawStr(0, 20, "TermoSystem ESP8266");
+  mainDisp.setFont(u8g2_font_5x8_tr);
+  mainDisp.drawStr(0, 34, FW_VERSION);
+  mainDisp.drawStr(0, 46, "by Stephan W.");
+  mainDisp.drawStr(0, 58, tr("OK lungo: Menu", "Hold OK: Menu"));
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiInfo() {
+  static bool selPrev = false;
+  static unsigned long selStart = 0;
+  bool selNow = (digitalRead(PIN_BTN_SELECT) == LOW);
+  unsigned long now = millis();
+
+  if (selNow && !selPrev) {
+    selStart = now;
+  }
+  if (!selNow && selPrev) {
+    unsigned long dur = now - selStart;
+    if (dur >= LONG_PRESS_MS) {
+      uiState = UI_MENU;
+    }
+  }
+  selPrev = selNow;
+
+  drawInfoScreen();
+}
+
+// =============================
+//  MENU HANDLER
+// =============================
+
+void drawMenu() {
+  mainDisp.clearBuffer();
+  drawTopBar(tr("Menu", "Menu"));
+
+  mainDisp.setFont(u8g2_font_6x10_tr);
+
+  for (int i = 0; i < MENU_VISIBLE; i++) {
+    int idx = menuTopIndex + i;
+    if (idx >= MENU_ITEMS) break;
+
+    int y = 20 + i * 10;
+    if (idx == menuIndex) {
+      mainDisp.drawBox(0, y-8, 128, 10);
+      mainDisp.setDrawColor(0);
+      mainDisp.setCursor(2, y);
+      mainDisp.print("> ");
+      mainDisp.print(menuLabels[mainMenu[idx].id][currentLanguage]);
+      mainDisp.setDrawColor(1);
+    } else {
+      mainDisp.setCursor(2, y);
+      mainDisp.print("  ");
+      mainDisp.print(menuLabels[mainMenu[idx].id][currentLanguage]);
+    }
+  }
+
+  mainDisp.sendBuffer();
+}
+
+void handleUiMenu() {
+  if (upPressed) {
+    menuIndex--;
+    if (menuIndex < 0) menuIndex = MENU_ITEMS - 1;
+  }
+  if (downPressed) {
+    menuIndex++;
+    if (menuIndex >= MENU_ITEMS) menuIndex = 0;
+  }
+
+  // gestione scroll: appena arrivi alla 4a voce, scorre
+  if (menuIndex < menuTopIndex) {
+    menuTopIndex = menuIndex;
+  }
+  if (menuIndex >= menuTopIndex + MENU_VISIBLE) {
+    menuTopIndex = menuIndex - MENU_VISIBLE + 1;
+  }
+
+  if (selectPressed) {
+    uiState = mainMenu[menuIndex].target;
+    if (uiState == UI_STATUS)  statusTopLine = 0;
+    if (uiState == UI_PUMP)    pumpScreenIndex = 0;
+    if (uiState == UI_TIME_SETTINGS) timeScreenIndex = 0;
+    if (uiState == UI_SYSTEM_SETTINGS) {
+      systemScreenIndex = 0;
+      systemTopIndex = 0;
+    }
+    if (uiState == UI_THEME_SELECT) {
+      themeScreenIndex = (int)currentTheme;
+      themeTopIndex = max(0, themeScreenIndex - THEME_VISIBLE + 1);
+    }
+    if (uiState == UI_LANGUAGE_SELECT) {
+      languageScreenIndex = (int)currentLanguage;
+    }
+    if (uiState == UI_SCREENSAVER_SETTINGS) {
+      screensaverScreenIndex = (int)screenSaverMode;
+    }
+    if (uiState == UI_OTA_UPDATE) {
+      otaStartRequested = true;
+    }
+    if (uiState == UI_FACTORY_RESET) {
+      factoryResetIndex = 0;
+    }
+  }
+
+  drawMenu();
+}
+
+// =============================
+//  STATUS HANDLER
+// =============================
+
+void handleUiStatus() {
+  if (upPressed)   statusTopLine--;
+  if (downPressed) statusTopLine++;
+  if (selectPressed) uiState = UI_MENU;
+  drawStatusScreen();
+}
+// =========================================================
+//  TermoSystem - v1.1 Beta
+//  BLOCCO 5: OLED pages + diagnostica
+// =========================================================
+
+enum OledPage {
+  OLED_PAGE_VITALS = 0,
+  OLED_PAGE_HOPPER,
+  OLED_PAGE_INFO,
+  OLED_PAGE_COUNT
+};
+
+OledPage      oledPage        = OLED_PAGE_VITALS;
+unsigned long oledLastChange  = 0;
+const unsigned long OLED_PAGE_INTERVAL = 5000;  // 5s per pagina
+
+// Per far apparire ogni tanto la mini animazione TermoSystem
+bool          oledLogoPhase   = false;
+unsigned long oledLogoTimer   = 0;
+const unsigned long OLED_LOGO_INTERVAL = 30000; // ogni ~30s
+
+// Piccolo helper per uptime compatto
+void formatUptimeShort(char* buf, size_t len) {
+  unsigned long sec = millis() / 1000;
+  unsigned long h = sec / 3600;
+  unsigned long m = (sec % 3600) / 60;
+  snprintf(buf, len, "%luh %lum", h, m);
+}
+
+// =============================
+//  MINI LOGO ANIMATO TERMOSYSTEM SU OLED
+// =============================
+void drawOledMiniLogo() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_6x10_tr);
+
+  const char* left  = "Termo";
+  const char* right = "System";
+
+  int wLeft  = oled.getStrWidth(left);
+  int wRight = oled.getStrWidth(right);
+
+  int centerY = 32;
+
+  int finalXLeft  = (128 - (wLeft + wRight + 4)) / 2;
+  int finalXRight = finalXLeft + wLeft + 4;
+
+  int startXLeft  = -wLeft;
+  int startXRight = 128;
+
+  const int steps = 14;
+
+  for (int i = 0; i <= steps; i++) {
+    float t = (float)i / (float)steps;
+    int curXLeft  = startXLeft  + (int)((finalXLeft  - startXLeft)  * t);
+    int curXRight = startXRight + (int)((finalXRight - startXRight) * t);
+
+    oled.clearBuffer();
+    oled.setFont(u8g2_font_6x10_tr);
+    oled.drawStr(curXLeft,  centerY,     left);
+    oled.drawStr(curXRight, centerY + 2, right);
+
+    oled.setFont(u8g2_font_4x6_tr);
+    oled.drawStr(0, 60, "by Stephan W.");
+    oled.sendBuffer();
+    delay(40);
+  }
+
+  delay(600);
+}
+
+// =============================
+//  OLED PAGE 0: VITALS
+// =============================
+void drawOledPageVitals() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_6x10_tr);
+  oled.drawStr(0, 10, "Vitals");
+
+  char buf[32];
+
+  // Puffer 1 & 2 (solo Tmax)
+  oled.setFont(u8g2_font_5x8_tr);
+  if (!isnan(puffer1.tMax)) snprintf(buf, sizeof(buf), "P1: %.1fC", puffer1.tMax);
+  else snprintf(buf, sizeof(buf), "P1: N/A");
+  oled.drawStr(0, 24, buf);
+
+  if (!isnan(puffer2.tMax)) snprintf(buf, sizeof(buf), "P2: %.1fC", puffer2.tMax);
+  else snprintf(buf, sizeof(buf), "P2: N/A");
+  oled.drawStr(0, 34, buf);
+
+  // Pompa
+  snprintf(buf, sizeof(buf), "Pump:%s", pumpRelayState ? "ON " : "OFF");
+  oled.drawStr(0, 44, buf);
+
+  snprintf(buf, sizeof(buf), "Mode:%s", pumpModeToString());
+  oled.drawStr(0, 54, buf);
+
+  oled.sendBuffer();
+}
+
+// =============================
+//  OLED PAGE 1: HOPPER + 5V + WIFI
+// =============================
+void drawOledPageHopper() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_6x10_tr);
+  oled.drawStr(0, 10, "Hopper & Power");
+
+  oled.setFont(u8g2_font_5x8_tr);
+  char buf[32];
+
+  // Hopper
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    snprintf(buf, sizeof(buf), "Hopper: %.0f%%", hopper.percent);
+  } else {
+    snprintf(buf, sizeof(buf), "Hopper: N/A");
+  }
+  oled.drawStr(0, 24, buf);
+
+  // 5V supply
+  snprintf(buf, sizeof(buf), "V 5V: %.2f", supplyVoltage5V);
+  oled.drawStr(0, 34, buf);
+
+  // Vcc MCU
+  snprintf(buf, sizeof(buf), "V MCU: %.2f", getVcc());
+  oled.drawStr(0, 44, buf);
+
+  // Wifi / AP
+  if (wifiConnected) {
+    snprintf(buf, sizeof(buf), "WiFi: OK");
+  } else if (apMode) {
+    snprintf(buf, sizeof(buf), "WiFi: AP");
+  } else {
+    snprintf(buf, sizeof(buf), "WiFi: NO");
+  }
+  oled.drawStr(0, 54, buf);
+
+  oled.sendBuffer();
+}
+
+// =============================
+//  OLED PAGE 2: INFO COMPATTA + UPTIME
+// =============================
+void drawOledPageInfo() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_5x8_tr);
+
+  oled.drawStr(0, 10, "TermoSystem v1.2.1");
+
+  char buf[32];
+  formatUptimeShort(buf, sizeof(buf));
+  oled.drawStr(0, 22, buf);
+
+  // Data/ora
+  char timeBuf[8];
+  formatTimeString(timeBuf, sizeof(timeBuf));
+  oled.drawStr(0, 34, timeBuf);
+
+  // piccolo stato mini
+  snprintf(buf, sizeof(buf), "P:%s AUX:%s",
+           pumpRelayState ? "ON" : "OFF",
+           auxRelayState  ? "ON" : "OFF");
+  oled.drawStr(0, 44, buf);
+
+  if (wifiConnected) {
+    oled.drawStr(0, 54, "Net: WiFi");
+  } else if (apMode) {
+    oled.drawStr(0, 54, "Net: AP only");
+  } else {
+    oled.drawStr(0, 54, "Net: offline");
+  }
+
+  oled.sendBuffer();
+}
+
+// =============================
+//  OLED DIAG RUNTIME
+// =============================
+void drawOledDiag() {
+  oled.clearBuffer();
+  oled.setFont(u8g2_font_5x8_tr);
+  oled.drawStr(0, 8, "DIAGNOSTICA");
+
+  int y = 18;
+  auto line = [&](const char* label, bool ok) {
+    oled.setCursor(0, y);
+    oled.print(label);
+    oled.print(ok ? ":OK" : ":N/A");
+    y += 8;
+  };
+
+  line("P1Mx", sonde[SONDA_P1_MAX].ok);
+  line("P1Mn", sonde[SONDA_P1_MIN].ok);
+  line("P2Mx", sonde[SONDA_P2_MAX].ok);
+  line("P2Mn", sonde[SONDA_P2_MIN].ok);
+  line("Pump", pumpRelayState);
+  line("WiFi", wifiConnected);
+
+  oled.sendBuffer();
+}
+
+// =============================
+//  OLED VITALS DISPATCHER (chiamato dal loop)
+// =============================
+void drawOledVitals() {
+  unsigned long now = millis();
+
+  // Se siamo in fase "logo", gestiamo solo quello per un breve periodo
+  if (oledLogoPhase) {
+    drawOledMiniLogo();
+    oledLogoPhase = false;
+    oledLogoTimer = now;  // riparte il contatore
+    return;
+  }
+
+  // Cambio pagina periodico
+  if (now - oledLastChange > OLED_PAGE_INTERVAL) {
+    oledLastChange = now;
+    oledPage = (OledPage)((int(oledPage) + 1) % OLED_PAGE_COUNT);
+  }
+
+  // Scatta la richiesta di mostrare il logo ogni X secondi
+  if (now - oledLogoTimer > OLED_LOGO_INTERVAL) {
+    oledLogoPhase = true;
+    // la prossima chiamata a drawOledVitals() farà l'animazione
+  }
+
+  switch (oledPage) {
+    case OLED_PAGE_VITALS: drawOledPageVitals(); break;
+    case OLED_PAGE_HOPPER: drawOledPageHopper(); break;
+    case OLED_PAGE_INFO:   drawOledPageInfo();   break;
+  }
+}
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 6: Logica pompa (isteresi) + LOOP principale
+// =========================================================
+
+// Supponiamo esistano già (dal Blocco 1) variabili globali:
+// - PumpMode pumpMode;
+// - bool pumpRelayState;
+// - bool pumpLogicInit;
+// - float pumpSetTemp;         // temperatura di avvio pompa
+// - float pumpHysteresis;      // isteresi in gradi (es. 1.5)
+// - SondaData sonde[SONDA_COUNT];
+// - PufferData puffer1;
+// e funzioni:
+// - void applyPumpState(bool on);
+
+// Se nel Blocco 1 non hai ancora inizializzato pumpHysteresis, usa 1.5
+#ifndef PUMP_HYST_DEFAULT_DEFINED
+float pumpHysteresis = 1.5f;
+#define PUMP_HYST_DEFAULT_DEFINED
+#endif
+
+// =============================
+//  LOGICA POMPA CON ISTERESI
+// =============================
+//
+// Richiesta:
+//  - appena P1 Tmax arriva alla temperatura desiderata (pumpSetTemp) -> pompa ON
+//  - per spegnere la pompa, P1 Tmax deve scendere di 1.5°C sotto il setpoint
+//    => soglia OFF = pumpSetTemp - pumpHysteresis
+//
+//  AUTO:
+//   - se sonda P1 MAX non ok -> pompa OFF (sicurezza)
+//   - se pompa OFF e T >= setpoint   -> accende
+//   - se pompa ON  e T <= setpoint - hysteresis -> spegne
+//
+//  FORCE ON / FORCE OFF bypassano la logica AUTO
+//
+
+
+// =============================
+//  LOOP PRINCIPALE
+// =============================
+
+void loop() {
+  // Gestione richieste HTTP (WebApp / API)
+  server.handleClient();
+
+  // Aggiorna sensori (tutte e 4 le sonde, hopper, ecc.)
+  updateSensors();
+
+  // Logica pompa con isteresi e modalità
+  updatePumpLogic();
+  addHistorySample();
+  updateDailyMetrics();
+  updateMqtt();
+
+
+  // OLED: se siamo in modalità diagnosi (OK tenuto premuto all'avvio)
+  // mostra sempre la diagnostica; altrimenti il carosello di pagine.
+  if (diagMode) {
+    drawOledDiag();
+  } else {
+    drawOledVitals();
+  }
+
+  // Pulsanti (one-shot: upPressed / downPressed / selectPressed)
+  readButtons();
+  updateScreensaverState();
+  if (displaySleeping) {
+    delay(80);
+    return;
+  }
+
+  // Gestione stato UI principale sul display GM128x64
+  switch (uiState) {
+    case UI_DASHBOARD: {
+      // Dashboard con temi; pulsante OK apre il menu
+      if (selectPressed) {
+        uiState    = UI_MENU;
+        menuIndex  = 0;
+        menuTopIndex = 0;
+      }
+      drawDashboard();
+      break;
+    }
+
+    case UI_MENU: {
+      handleUiMenu();
+      break;
+    }
+
+    case UI_STATUS: {
+      handleUiStatus();
+      break;
+    }
+
+    case UI_PUMP: {
+      handleUiPump();
+      break;
+    }
+
+    case UI_DISPLAY_SETTINGS: {
+      handleUiDisplaySettings();
+      break;
+    }
+
+    case UI_TIME_SETTINGS: {
+      handleUiTimeSettings();
+      break;
+    }
+
+    case UI_SYSTEM_SETTINGS: {
+      handleUiSystemSettings();
+      break;
+    }
+
+    case UI_THEME_SELECT: {
+      handleUiThemeSelect();
+      break;
+    }
+
+    case UI_LANGUAGE_SELECT: {
+      handleUiLanguageSelect();
+      break;
+    }
+
+    case UI_SCREENSAVER_SETTINGS: {
+      handleUiScreensaverSettings();
+      break;
+    }
+
+    case UI_SCREENSAVER: {
+      drawScreensaver();
+      break;
+    }
+
+    case UI_OTA_UPDATE: {
+      handleUiOtaUpdate();
+      break;
+    }
+
+    case UI_FACTORY_RESET: {
+      handleUiFactoryReset();
+      break;
+    }
+
+    case UI_DIAG: {
+      handleUiDiag();
+      break;
+    }
+
+    case UI_INFO: {
+      handleUiInfo();
+      break;
+    }
+  }
+
+  // Piccola pausa per non saturare la CPU e per dare tempo ai display
+  delay(80);
+}
+// =========================================================
+//  TermoSystem - v1.2.1
+//  BLOCCO 7: Storico, API avanzate, WebApp animata
+// =========================================================
+
+// =============================
+//  STORICO TEMPERATURE & POMPA
+// =============================
+
+const int HIST_LEN = 60;               // ultimi 60 campioni
+float histT1[HIST_LEN];                // P1 Tmax
+float histT2[HIST_LEN];                // P2 Tmax
+bool  histPump[HIST_LEN];              // stato pompa
+unsigned long histTs[HIST_LEN];        // timestamp (millis / 1000)
+int   histCount      = 0;
+int   histHead       = 0;
+unsigned long lastHistSampleMs = 0;
+const unsigned long HIST_INTERVAL_MS = 60000;   // 1 minuto
+
+
+void addHistorySample() {
+  unsigned long now = millis();
+  if (now - lastHistSampleMs < HIST_INTERVAL_MS) return;
+  lastHistSampleMs = now;
+
+  int idx = histHead;
+  histHead = (histHead + 1) % HIST_LEN;
+  if (histCount < HIST_LEN) histCount++;
+
+  histT1[idx]   = puffer1.tMax;
+  histT2[idx]   = puffer2.tMax;
+  histPump[idx] = pumpRelayState;
+  histTs[idx]   = now / 1000;
+}
+
+// =============================
+//  API /api/status
+// =============================
+
+void handleApiStatus() {
+  String json = "{";
+
+  // Firmware
+  json += "\"fw\":\"" + String(FW_VERSION) + "\",";
+
+  // Puffer 1 & 2
+  json += "\"p1Max\":";
+  if (!isnan(puffer1.tMax)) json += String(puffer1.tMax, 1);
+  else json += "\"NaN\"";
+  json += ",";
+
+  json += "\"p1Min\":";
+  if (!isnan(puffer1.tMin)) json += String(puffer1.tMin, 1);
+  else json += "\"NaN\"";
+  json += ",";
+
+  json += "\"p2Max\":";
+  if (!isnan(puffer2.tMax)) json += String(puffer2.tMax, 1);
+  else json += "\"NaN\"";
+  json += ",";
+
+  json += "\"p2Min\":";
+  if (!isnan(puffer2.tMin)) json += String(puffer2.tMin, 1);
+  else json += "\"NaN\"";
+  json += ",";
+
+  // Pompa
+  json += "\"pumpOn\":" + String(pumpRelayState ? "true" : "false") + ",";
+  json += "\"pumpMode\":\"" + String(pumpModeToString()) + "\",";
+  json += "\"pumpSetTemp\":" + String(pumpSetTemp, 1) + ",";
+  json += "\"pumpHyst\":" + String(pumpHysteresis, 1) + ",";
+
+  // AUX
+  json += "\"auxOn\":" + String(auxRelayState ? "true" : "false") + ",";
+
+  // Hopper
+  json += "\"hopperPercent\":";
+  if (hopper.hasSensor && hopper.percent >= 0.0f && hopper.percent <= 100.0f) {
+    json += String(hopper.percent, 1);
+  } else {
+    json += "\"NaN\"";
+  }
+  json += ",";
+
+  // Statistiche giornaliere
+  json += "\"dailyPumpOnMin\":" + String((int)(dailyPumpOnMs / 60000UL)) + ",";
+  json += "\"dailyLowTempEvents\":" + String(dailyLowTempEvents) + ",";
+  json += "\"dailyMinP1\":";
+  if (!isnan(dailyMinP1)) json += String(dailyMinP1, 1);
+  else json += "\"NaN\"";
+  json += ",";
+  json += "\"dailyMaxP1\":";
+  if (!isnan(dailyMaxP1)) json += String(dailyMaxP1, 1);
+  else json += "\"NaN\"";
+  json += ",";
+
+  // Alimentazioni
+  json += "\"vcc\":" + String(getVcc(), 2) + ",";
+  json += "\"v5\":"  + String(supplyVoltage5V, 2) + ",";
+
+  // WiFi
+  json += "\"wifiConnected\":" + String(wifiConnected ? "true" : "false") + ",";
+  json += "\"apMode\":"        + String(apMode ? "true" : "false") + ",";
+  if (wifiConnected) {
+    json += "\"ssid\":\"" + WiFi.SSID() + "\",";
+    json += "\"ip\":\""   + WiFi.localIP().toString() + "\",";
+  } else {
+    json += "\"ssid\":\"\",";
+    json += "\"ip\":\"\",";
+  }
+
+  // Tempo & tema
+  json += "\"uptimeSec\":" + String(millis() / 1000) + ",";
+  json += "\"clockUseNtp\":" + String(clockUseNtp ? "true" : "false") + ",";
+  json += "\"clockIs24h\":"  + String(clockIs24h ? "true" : "false") + ",";
+  json += "\"clockTzIndex\":" + String(clockTzIndex) + ",";
+  json += "\"theme\":"        + String((int)currentTheme);
+
+  json += "}";
+
+  server.send(200, "application/json", json);
+}
+
+// =============================
+//  API /api/settings
+//  GET: restituisce configurazione
+//  POST: aggiorna vari parametri
+// =============================
+
+void handleApiSettingsGet() {
+  String json = "{";
+
+  json += "\"pumpMode\":\"" + String(pumpModeToString()) + "\",";
+  json += "\"pumpSetTemp\":" + String(pumpSetTemp, 1) + ",";
+  json += "\"pumpHyst\":"    + String(pumpHysteresis, 1) + ",";
+
+  json += "\"auxOn\":" + String(auxRelayState ? "true" : "false") + ",";
+
+  json += "\"puffer1Enabled\":" + String(puffer1.enabled ? "true" : "false") + ",";
+  json += "\"puffer2Enabled\":" + String(puffer2.enabled ? "true" : "false") + ",";
+
+  json += "\"s1Enabled\":" + String(sonde[SONDA_P1_MAX].enabled ? "true" : "false") + ",";
+  json += "\"s2Enabled\":" + String(sonde[SONDA_P1_MIN].enabled ? "true" : "false") + ",";
+  json += "\"s3Enabled\":" + String(sonde[SONDA_P2_MAX].enabled ? "true" : "false") + ",";
+  json += "\"s4Enabled\":" + String(sonde[SONDA_P2_MIN].enabled ? "true" : "false") + ",";
+
+  json += "\"contrast\":" + String(mainContrast) + ",";
+  json += "\"flip\":"     + String(mainFlip) + ",";
+
+  json += "\"clockUseNtp\":" + String(clockUseNtp ? "true" : "false") + ",";
+  json += "\"clockIs24h\":"  + String(clockIs24h ? "true" : "false") + ",";
+  json += "\"clockTzIndex\":" + String(clockTzIndex) + ",";
+
+  json += "\"theme\":" + String((int)currentTheme);
+
+  json += "}";
+  server.send(200, "application/json", json);
+}
+
+void handleApiSettingsPost() {
+  if (server.method() != HTTP_POST) {
+    server.send(405, "text/plain", "Metodo non valido");
+    return;
+  }
+
+  // Pompa
+  if (server.hasArg("pumpMode")) {
+    String m = server.arg("pumpMode");
+    if (m == "AUTO") pumpMode = PUMP_AUTO;
+    else if (m == "ON") pumpMode = PUMP_FORCE_ON;
+    else if (m == "OFF") pumpMode = PUMP_FORCE_OFF;
+  }
+
+  if (server.hasArg("pumpSetTemp")) {
+    float t = server.arg("pumpSetTemp").toFloat();
+    if (t < 10.0f) t = 10.0f;
+    if (t > 90.0f) t = 90.0f;
+    pumpSetTemp = t;
+  }
+
+  if (server.hasArg("pumpHyst")) {
+    float h = server.arg("pumpHyst").toFloat();
+    if (h < 0.5f) h = 0.5f;
+    if (h > 10.0f) h = 10.0f;
+    pumpHysteresis = h;
+  }
+
+  // AUX
+  if (server.hasArg("auxOn")) {
+    String v = server.arg("auxOn");
+    auxRelayState = (v == "1" || v == "true" || v == "on");
+    applyAuxRelay(auxRelayState);
+  }
+
+  // Puffer & sonde
+  if (server.hasArg("puffer1Enabled")) {
+    String v = server.arg("puffer1Enabled");
+    puffer1.enabled = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("puffer2Enabled")) {
+    String v = server.arg("puffer2Enabled");
+    puffer2.enabled = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("s1Enabled")) {
+    String v = server.arg("s1Enabled");
+    sonde[SONDA_P1_MAX].enabled = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("s2Enabled")) {
+    String v = server.arg("s2Enabled");
+    sonde[SONDA_P1_MIN].enabled = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("s3Enabled")) {
+    String v = server.arg("s3Enabled");
+    sonde[SONDA_P2_MAX].enabled = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("s4Enabled")) {
+    String v = server.arg("s4Enabled");
+    sonde[SONDA_P2_MIN].enabled = (v == "1" || v == "true" || v == "on");
+  }
+
+  // Display
+  if (server.hasArg("contrast")) {
+    int c = server.arg("contrast").toInt();
+    if (c < 0) c = 0;
+    if (c > 255) c = 255;
+    mainContrast = (uint8_t)c;
+    mainDisp.setContrast(mainContrast);
+  }
+
+  if (server.hasArg("flip")) {
+    int f = server.arg("flip").toInt();
+    mainFlip = (f > 0) ? 1 : 0;
+    mainDisp.setFlipMode(mainFlip);
+  }
+
+  // Orologio
+  if (server.hasArg("clockUseNtp")) {
+    String v = server.arg("clockUseNtp");
+    clockUseNtp = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("clockIs24h")) {
+    String v = server.arg("clockIs24h");
+    clockIs24h = (v == "1" || v == "true" || v == "on");
+  }
+  if (server.hasArg("clockTzIndex")) {
+    int idx = server.arg("clockTzIndex").toInt();
+    if (idx < 0) idx = 0;
+    if (idx >= TIMEZONES_COUNT) idx = TIMEZONES_COUNT - 1;
+    clockTzIndex = idx;
+  }
+
+  // Tema
+  if (server.hasArg("theme")) {
+    int t = server.arg("theme").toInt();
+    if (t < 0) t = 0;
+    if (t >= THEME_COUNT) t = THEME_COUNT - 1;
+    currentTheme = (ThemeId)t;
+  }
+
+  // Salva configurazione globale (display, orologio, tema, puffer/sonde/AUX)
+  saveGlobalConfig();
+  // Config pompa
+  savePumpConfig();
+
+  // Ritorna settaggi aggiornati
+  handleApiSettingsGet();
+}
+
+// =============================
+//  API /api/history
+// =============================
+
+void handleApiHistory() {
+  String json = "{";
+  json += "\"samples\":[";
+  int n = histCount;
+  for (int i = 0; i < n; i++) {
+    int idx = (histHead - n + i);
+    if (idx < 0) idx += HIST_LEN;
+
+    json += "{";
+
+    json += "\"t1\":";
+    if (!isnan(histT1[idx])) json += String(histT1[idx], 1);
+    else json += "null";
+    json += ",";
+
+    json += "\"t2\":";
+    if (!isnan(histT2[idx])) json += String(histT2[idx], 1);
+    else json += "null";
+    json += ",";
+
+    json += "\"p\":";
+    json += histPump[idx] ? "1" : "0";
+    json += ",";
+
+    json += "\"ts\":";
+    json += String(histTs[idx]);
+
+    json += "}";
+    if (i < n-1) json += ",";
+  }
+  json += "]}";
+
+  server.send(200, "application/json", json);
+}
+
+// =============================
+//  WEBAPP HTML ANIMATA
+// =============================
+
+const char APP_HTML[] PROGMEM = R"====(
+<!DOCTYPE html>
+<html lang="it">
+<head>
+<meta charset="UTF-8">
+<title>TermoSystem WebApp</title>
+<meta name="viewport" content="width=device-width, initial-scale=1">
+<style>
+:root{
+  --bg:#090909;
+  --card:#151515;
+  --accent:#4caf50;
+  --accent2:#2196f3;
+  --danger:#e53935;
+  --text:#f0f0f0;
+  --muted:#777;
+  --hot:#ff5252;
+  --cold:#4fc3f7;
+}
+body{
+  margin:0;
+  font-family:system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
+  background:var(--bg);
+  color:var(--text);
+}
+header{
+  position:sticky;
+  top:0;
+  z-index:10;
+  display:flex;
+  align-items:center;
+  justify-content:space-between;
+  padding:10px 16px;
+  background:rgba(0,0,0,0.92);
+  border-bottom:1px solid #222;
+}
+.logo{
+  font-weight:700;
+  font-size:1.1rem;
+}
+.logo span{
+  color:var(--accent);
+}
+#fwBadge{
+  font-size:0.75rem;
+  color:var(--muted);
+}
+main{
+  max-width:980px;
+  margin:0 auto;
+  padding:10px;
+}
+.card{
+  background:var(--card);
+  border-radius:12px;
+  padding:10px 12px;
+  margin-bottom:10px;
+  box-shadow:0 0 12px rgba(0,0,0,0.65);
+}
+.card h2{
+  margin:0 0 8px;
+  font-size:1rem;
+  display:flex;
+  align-items:center;
+  justify-content:space-between;
+}
+.row{
+  display:flex;
+  flex-wrap:wrap;
+  gap:8px;
+}
+.tile{
+  flex:1;
+  min-width:140px;
+  background:rgba(0,0,0,0.35);
+  border-radius:10px;
+  padding:6px 8px;
+}
+.label{
+  font-size:0.75rem;
+  color:var(--muted);
+}
+.value{
+  font-size:1.1rem;
+  font-weight:600;
+}
+.small{
+  font-size:0.75rem;
+  color:var(--muted);
+}
+.status-dot{
+  display:inline-block;
+  width:9px;height:9px;
+  border-radius:50%;
+  margin-right:4px;
+}
+.ok{background:var(--accent);}
+.warn{background:#fbc02d;}
+.err{background:var(--danger);}
+
+/* SCHEMA IMPIANTO */
+.schema{
+  display:grid;
+  grid-template-columns:repeat(4, minmax(70px, 1fr));
+  gap:16px;
+  align-items:end;
+  min-height:160px;
+}
+.schema-item{
+  display:flex;
+  flex-direction:column;
+  align-items:center;
+  gap:6px;
+}
+.puffer{
+  position:relative;
+  width:70px;
+  height:140px;
+  border-radius:10px;
+  overflow:hidden;
+  border:2px solid #555;
+  background:linear-gradient(to top, var(--cold), var(--hot));
+}
+.puffer-inner{
+  position:absolute;
+  left:0;bottom:0;
+  width:100%;
+  height:100%;
+  background:linear-gradient(to top, var(--cold) 50%, var(--hot) 50%);
+  transition:background-position 0.4s, clip-path 0.4s, height 0.4s;
+}
+.puffer-label{
+  position:absolute;
+  top:2px;
+  left:4px;
+  font-size:0.7rem;
+}
+.puffer-temp{
+  position:absolute;
+  bottom:4px;
+  left:4px;
+  font-size:0.8rem;
+  font-weight:600;
+  text-shadow:0 0 4px #000;
+}
+
+/* Hopper */
+.hopper{
+  position:relative;
+  width:60px;
+  height:120px;
+  border-radius:8px 8px 10px 10px;
+  border:2px solid #666;
+  overflow:hidden;
+  background:linear-gradient(to top,#3e2723,#4e342e);
+}
+.hopper-fill{
+  position:absolute;
+  left:0;bottom:0;
+  width:100%;
+  height:0%;
+  background:repeating-linear-gradient(
+    45deg,
+    #ffeb3b,
+    #ffeb3b 4px,
+    #fbc02d 4px,
+    #fbc02d 8px
+  );
+  transition:height 0.4s;
+}
+.hopper-label{
+  position:absolute;
+  top:2px;
+  left:4px;
+  font-size:0.7rem;
+}
+.hopper-perc{
+  position:absolute;
+  bottom:4px;
+  width:100%;
+  text-align:center;
+  font-size:0.8rem;
+}
+
+/* Pompa */
+.pump{
+  position:relative;
+  width:52px;
+  height:52px;
+  border-radius:50%;
+  border:3px solid #888;
+  display:flex;
+  align-items:center;
+  justify-content:center;
+  overflow:hidden;
+}
+.pump-label{
+  font-size:0.75rem;
+  color:var(--muted);
+}
+.pump-inner{
+  width:24px;
+  height:24px;
+  border-radius:50%;
+  border:2px solid #777;
+  position:relative;
+}
+.pump-blade{
+  position:absolute;
+  inset:2px;
+  border-radius:50%;
+  border-top:3px solid var(--accent);
+  border-right:3px solid transparent;
+  border-bottom:3px solid transparent;
+  border-left:3px solid transparent;
+  transform-origin:50% 50%;
+  animation:pumpSpin 1.2s linear infinite;
+}
+.pump.off .pump-blade{
+  animation:none;
+  opacity:0.3;
+  border-top-color:#666;
+}
+@keyframes pumpSpin{
+  from{transform:rotate(0deg);}
+  to{transform:rotate(360deg);}
+}
+
+/* Grafico storico */
+#histCanvas{
+  width:100%;
+  max-width:940px;
+  height:200px;
+  background:#050505;
+  border-radius:8px;
+  border:1px solid #333;
+}
+
+/* Controlli */
+input[type=range], input[type=number], select{
+  width:100%;
+  margin-top:4px;
+  background:#111;
+  color:var(--text);
+  border-radius:6px;
+  border:1px solid #444;
+  padding:4px;
+}
+button{
+  border:none;
+  border-radius:8px;
+  padding:6px 12px;
+  font-size:0.85rem;
+  background:var(--accent);
+  color:#fff;
+  cursor:pointer;
+}
+button:active{
+  transform:scale(0.97);
+}
+.toggle-row{
+  display:flex;
+  flex-wrap:wrap;
+  gap:8px;
+}
+.toggle{
+  flex:1;
+  min-width:120px;
+  font-size:0.8rem;
+  display:flex;
+  align-items:center;
+  justify-content:space-between;
+}
+.toggle input{
+  transform:scale(1.1);
+}
+
+/* Temi WebApp */
+body.theme-techno{
+  --bg:#02030a;
+  --card:#05071a;
+  --accent:#00e676;
+  --accent2:#18ffff;
+  --hot:#ff4081;
+  --cold:#00b0ff;
+}
+body.theme-darklines{
+  --bg:#000000;
+  --card:#111111;
+  --accent:#8bc34a;
+  --accent2:#ffc107;
+}
+body.theme-wave{
+  --bg:#00141f;
+  --card:#021b27;
+  --accent:#4dd0e1;
+  --accent2:#80cbc4;
+}
+body.theme-christmas{
+  --bg:#050b05;
+  --card:#102010;
+  --accent:#c8e6c9;
+  --accent2:#ffeb3b;
+  --hot:#ff5252;
+  --cold:#64b5f6;
+}
+.christmas-banner{
+  font-size:0.8rem;
+  color:#ffeb3b;
+}
+
+/* Responsive */
+@media (max-width:600px){
+  .schema{
+    grid-template-columns:repeat(2, minmax(70px, 1fr));
+  }
+}
+</style>
+</head>
+<body class="theme-classic">
+<header>
+  <div class="logo">Termo<span>System</span> Web</div>
+  <div id="fwBadge"></div>
+</header>
+<main>
+  <!-- Schema animato impianto -->
+  <section class="card">
+    <h2>
+      Schema impianto
+      <span id="christmasBadge" class="small"></span>
+    </h2>
+    <div class="schema">
+      <div class="schema-item">
+        <div class="puffer" id="puffer2">
+          <div class="puffer-inner" id="p2Inner"></div>
+          <div class="puffer-label">Puffer 2</div>
+          <div class="puffer-temp" id="p2Temp">--.- °C</div>
+        </div>
+      </div>
+      <div class="schema-item">
+        <div class="puffer" id="puffer1">
+          <div class="puffer-inner" id="p1Inner"></div>
+          <div class="puffer-label">Puffer 1</div>
+          <div class="puffer-temp" id="p1Temp">--.- °C</div>
+        </div>
+      </div>
+      <div class="schema-item">
+        <div class="pump" id="pumpVis">
+          <div class="pump-inner">
+            <div class="pump-blade"></div>
+          </div>
+        </div>
+        <div class="pump-label">Pompa</div>
+      </div>
+      <div class="schema-item">
+        <div class="hopper">
+          <div class="hopper-fill" id="hopperFill"></div>
+          <div class="hopper-label">Hopper</div>
+          <div class="hopper-perc" id="hopperPerc">N/A</div>
+        </div>
+      </div>
+    </div>
+    <div class="small">
+      Schema semplificato e più chiaro: puffer, pompa di ritorno e hopper separati.
+    </div>
+  </section>
+
+  <!-- Stato impianto -->
+  <section class="card">
+    <h2>Stato impianto</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">Puffer 1 Tmax / Tmin</div>
+        <div class="value" id="valP1">--.- / --.- °C</div>
+        <div class="small">Sonde P1</div>
+      </div>
+      <div class="tile">
+        <div class="label">Puffer 2 Tmax / Tmin</div>
+        <div class="value" id="valP2">--.- / --.- °C</div>
+        <div class="small">Sonde P2</div>
+      </div>
+      <div class="tile">
+        <div class="label">Pompa</div>
+        <div class="value" id="valPump">OFF</div>
+        <div class="small" id="valPumpMode">Modo: --</div>
+      </div>
+    </div>
+  </section>
+
+  <!-- Consumi e statistiche -->
+  <section class="card">
+    <h2>Consumi & statistiche</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">Pompa attiva oggi</div>
+        <div class="value" id="valDailyPump">-- min</div>
+        <div class="small">Tempo totale pompa ON.</div>
+      </div>
+      <div class="tile">
+        <div class="label">Eventi sotto soglia</div>
+        <div class="value" id="valLowTemp">--</div>
+        <div class="small">Quante volte P1 è sceso sotto soglia.</div>
+      </div>
+      <div class="tile">
+        <div class="label">P1 min/max oggi</div>
+        <div class="value" id="valDailyRange">-- / -- °C</div>
+        <div class="small">Range giornaliero Puffer 1.</div>
+      </div>
+    </div>
+  </section>
+
+  <!-- Accesso remoto -->
+  <section class="card">
+    <h2>Accesso remoto</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">IP locale</div>
+        <div class="value" id="valRemoteIp">--</div>
+        <div class="small">Usa port forwarding sul router per l'accesso remoto.</div>
+      </div>
+      <div class="tile">
+        <div class="label">MQTT (widget)</div>
+        <div class="value">termosystem/status</div>
+        <div class="small">Pubblica lo stato per widget esterni (MQTT).</div>
+      </div>
+    </div>
+  </section>
+
+  <!-- Controllo pompa e display -->
+  <section class="card">
+    <h2>Controllo pompa & display</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">Modo pompa</div>
+        <select id="selPumpMode">
+          <option value="AUTO">Auto</option>
+          <option value="ON">Forzata ON</option>
+          <option value="OFF">Forzata OFF</option>
+        </select>
+        <div class="small">AUTO usa isteresi per proteggere la pompa.</div>
+      </div>
+      <div class="tile">
+        <div class="label">Temperatura avvio pompa (°C)</div>
+        <input type="number" id="numPumpSet" min="10" max="90" step="0.5">
+        <div class="small">La pompa si spegne a Set - 1.5°C.</div>
+      </div>
+      <div class="tile">
+        <div class="label">Contrasto display</div>
+        <input type="range" id="rangeContrast" min="0" max="255">
+        <div class="small">Orientamento</div>
+        <select id="selFlip">
+          <option value="0">Normale</option>
+          <option value="1">Capovolto</option>
+        </select>
+      </div>
+    </div>
+    <br>
+    <div class="row">
+      <div class="tile">
+        <div class="label">Tema dashboard</div>
+        <select id="selTheme">
+          <option value="0">Classic</option>
+          <option value="1">Techno</option>
+          <option value="2">Dark Lines</option>
+          <option value="3">Wave Flow</option>
+          <option value="4">Christmas</option>
+        </select>
+        <div class="small">Il 25 dicembre il tema natalizio è predefinito.</div>
+      </div>
+      <div class="tile">
+        <div class="label">Rele AUX</div>
+        <div class="toggle">
+          <span>AUX (D0)</span>
+          <input type="checkbox" id="chkAux">
+        </div>
+        <div class="small">Uscita ausiliaria ON/OFF.</div>
+      </div>
+    </div>
+    <br>
+    <button id="btnSaveSettings">Salva impostazioni</button>
+  </section>
+
+  <!-- Impostazioni puffer / sonde / orologio -->
+  <section class="card">
+    <h2>Impostazioni avanzate</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">Puffer & Sonde</div>
+        <div class="toggle-row">
+          <div class="toggle"><span>Puffer 1</span><input type="checkbox" id="chkP1"></div>
+          <div class="toggle"><span>Puffer 2</span><input type="checkbox" id="chkP2"></div>
+          <div class="toggle"><span>Sonda P1 MAX</span><input type="checkbox" id="chkS1"></div>
+          <div class="toggle"><span>Sonda P1 MIN</span><input type="checkbox" id="chkS2"></div>
+          <div class="toggle"><span>Sonda P2 MAX</span><input type="checkbox" id="chkS3"></div>
+          <div class="toggle"><span>Sonda P2 MIN</span><input type="checkbox" id="chkS4"></div>
+        </div>
+      </div>
+      <div class="tile">
+        <div class="label">Orologio</div>
+        <div class="toggle">
+          <span>Internet time (NTP)</span>
+          <input type="checkbox" id="chkNtp">
+        </div>
+        <div class="toggle">
+          <span>Formato 24h</span>
+          <input type="checkbox" id="chk24h">
+        </div>
+        <div class="small">Fuso orario</div>
+        <select id="selTz"></select>
+      </div>
+    </div>
+  </section>
+
+  <!-- Stato di sistema -->
+  <section class="card">
+    <h2>Stato di sistema</h2>
+    <div class="row">
+      <div class="tile">
+        <div class="label">WiFi</div>
+        <div class="value" id="valWifi">
+          <span class="status-dot err"></span>Offline
+        </div>
+        <div class="small" id="valIp"></div>
+      </div>
+      <div class="tile">
+        <div class="label">Alimentazioni</div>
+        <div class="value" id="valVcc">--.- V / --.- V</div>
+        <div class="small" id="valUptime">Uptime: --</div>
+      </div>
+    </div>
+  </section>
+
+  <!-- Grafico storico -->
+  <section class="card">
+    <h2>Storico temperature</h2>
+    <canvas id="histCanvas"></canvas>
+    <div class="small">
+      Puffer 1 (linea principale), Puffer 2, e barre in basso quando la pompa è ON.
+    </div>
+  </section>
+
+  <section class="card small">
+    <a href="/" style="color:var(--accent);text-decoration:none;">&larr; Torna alla pagina principale</a>
+  </section>
+</main>
+
+<script>
+let statusData = null;
+let lastHistory = [];
+
+// Mappa indice tema firmware -> classe body
+function applyWebTheme(themeIndex){
+  const body = document.body;
+  body.classList.remove("theme-classic","theme-techno","theme-darklines","theme-wave","theme-christmas");
+  switch(themeIndex){
+    case 1: body.classList.add("theme-techno"); break;
+    case 2: body.classList.add("theme-darklines"); break;
+    case 3: body.classList.add("theme-wave"); break;
+    case 4: body.classList.add("theme-christmas"); break;
+    default:body.classList.add("theme-classic"); break;
+  }
+}
+
+// Semplice lista fusi (indice deve combaciare con firmware)
+const TZ_LABELS = [
+  "Europe/Rome",
+  "Europe/London",
+  "Europe/Berlin",
+  "Europe/Madrid",
+  "Europe/Paris",
+  "UTC",
+  "America/New_York",
+  "America/Los_Angeles",
+  "Asia/Tokyo"
+];
+
+// Popola select fuso orario
+(function initTzSelect(){
+  const sel = document.getElementById('selTz');
+  TZ_LABELS.forEach((name, idx)=>{
+    const opt = document.createElement('option');
+    opt.value = idx;
+    opt.textContent = name;
+    sel.appendChild(opt);
+  });
+})();
+
+// Natale?
+function isTodayChristmas(){
+  const now = new Date();
+  return now.getMonth() === 11 && now.getDate() === 25;
+}
+
+// Aggiorna schema grafico puffer + hopper + pompa
+function updateSchemaFromStatus(s){
+  const p1Inner = document.getElementById('p1Inner');
+  const p2Inner = document.getElementById('p2Inner');
+  const p1Temp  = document.getElementById('p1Temp');
+  const p2Temp  = document.getElementById('p2Temp');
+  const hopperFill = document.getElementById('hopperFill');
+  const hopperPerc = document.getElementById('hopperPerc');
+  const pumpVis = document.getElementById('pumpVis');
+
+  // Puffer 1
+  if(s.p1Max === "NaN" || s.p1Max === null || s.p1Max === undefined){
+    p1Temp.textContent = "N/A";
+    p1Inner.style.background = "linear-gradient(to top, var(--cold), var(--hot))";
+  }else{
+    p1Temp.textContent = s.p1Max.toFixed(1) + " °C";
+    const ratio = Math.max(0, Math.min(1, (s.p1Max - 20) / 60));
+    const hotPart = (ratio*100).toFixed(1);
+    p1Inner.style.background = `linear-gradient(to top, var(--cold) 0%, var(--cold) ${100-hotPart}%, var(--hot) ${100-hotPart}%, var(--hot) 100%)`;
+  }
+
+  // Puffer 2
+  if(s.p2Max === "NaN" || s.p2Max === null || s.p2Max === undefined){
+    p2Temp.textContent = "N/A";
+    p2Inner.style.background = "linear-gradient(to top, var(--cold), var(--hot))";
+  }else{
+    p2Temp.textContent = s.p2Max.toFixed(1) + " °C";
+    const ratio = Math.max(0, Math.min(1, (s.p2Max - 20) / 60));
+    const hotPart = (ratio*100).toFixed(1);
+    p2Inner.style.background = `linear-gradient(to top, var(--cold) 0%, var(--cold) ${100-hotPart}%, var(--hot) ${100-hotPart}%, var(--hot) 100%)`;
+  }
+
+  // Hopper
+  if(s.hopperPercent === "NaN" || s.hopperPercent === null || s.hopperPercent === undefined){
+    hopperFill.style.height = "0%";
+    hopperPerc.textContent = "N/A";
+  }else{
+    const perc = Math.max(0, Math.min(100, s.hopperPercent));
+    hopperFill.style.height = perc + "%";
+    hopperPerc.textContent  = perc.toFixed(0) + "%";
+  }
+
+  // Pompa ON/OFF
+  if(s.pumpOn){
+    pumpVis.classList.remove("off");
+  }else{
+    pumpVis.classList.add("off");
+  }
+}
+
+// Aggiorna widget stato
+function updateWidgetsFromStatus(s){
+  document.getElementById('fwBadge').textContent = s.fw || "";
+
+  // Puffer details
+  const p1Line = (s.p1Max==="NaN" ? "N/A" : s.p1Max.toFixed(1)) +
+                 " / " +
+                 (s.p1Min==="NaN" ? "N/A" : s.p1Min.toFixed(1)) + " °C";
+  document.getElementById('valP1').textContent = p1Line;
+
+  const p2Line = (s.p2Max==="NaN" ? "N/A" : s.p2Max.toFixed(1)) +
+                 " / " +
+                 (s.p2Min==="NaN" ? "N/A" : s.p2Min.toFixed(1)) + " °C";
+  document.getElementById('valP2').textContent = p2Line;
+
+  // Pompa
+  document.getElementById('valPump').textContent = s.pumpOn ? "ON" : "OFF";
+  document.getElementById('valPumpMode').textContent = "Modo: " + (s.pumpMode || "--");
+
+  // WiFi
+  const wifiEl = document.getElementById('valWifi');
+  const ipEl   = document.getElementById('valIp');
+  if(s.wifiConnected){
+    wifiEl.innerHTML = '<span class="status-dot ok"></span>Online';
+    ipEl.textContent = s.ip ? ("IP: " + s.ip) : "";
+  }else if(s.apMode){
+    wifiEl.innerHTML = '<span class="status-dot warn"></span>Solo AP';
+    ipEl.textContent = "AP: 192.168.4.1";
+  }else{
+    wifiEl.innerHTML = '<span class="status-dot err"></span>Offline';
+    ipEl.textContent = "";
+  }
+
+  const remoteIp = document.getElementById('valRemoteIp');
+  if(s.wifiConnected && s.ip){
+    remoteIp.textContent = s.ip;
+  }else if(s.apMode){
+    remoteIp.textContent = "192.168.4.1";
+  }else{
+    remoteIp.textContent = "--";
+  }
+
+  // Alimentazioni + uptime
+  const vcc = (s.vcc ?? 0).toFixed(2);
+  const v5  = (s.v5 ?? 0).toFixed(2);
+  document.getElementById('valVcc').textContent = vcc + " V / " + v5 + " V";
+
+  const u = s.uptimeSec ?? 0;
+  const h = Math.floor(u/3600), m = Math.floor((u%3600)/60), sec = u%60;
+  document.getElementById('valUptime').textContent =
+    `Uptime: ${h}h ${m}m ${sec}s`;
+
+  const pumpMin = s.dailyPumpOnMin ?? 0;
+  document.getElementById('valDailyPump').textContent = `${pumpMin} min`;
+  document.getElementById('valLowTemp').textContent = s.dailyLowTempEvents ?? 0;
+  const minP1 = (s.dailyMinP1==="NaN" ? "N/A" : s.dailyMinP1.toFixed(1));
+  const maxP1 = (s.dailyMaxP1==="NaN" ? "N/A" : s.dailyMaxP1.toFixed(1));
+  document.getElementById('valDailyRange').textContent = `${minP1} / ${maxP1} °C`;
+
+  // Controlli base (solo se abbiamo anche settings, ma per sicurezza facciamo qui)
+  document.getElementById('numPumpSet').value = s.pumpSetTemp ?? 45.0;
+
+  // Tema natalizio auto il 25/12
+  const christmasBadge = document.getElementById('christmasBadge');
+  if(isTodayChristmas() || s.theme === 4){
+    christmasBadge.textContent = "🎄 Modalità Natale";
+    document.body.classList.add("theme-christmas");
+  }
+
+  applyWebTheme(s.theme ?? 0);
+  document.getElementById('selTheme').value = s.theme ?? 0;
+}
+
+// Disegno grafico storico
+function drawHistoryCanvas(samples){
+  const canvas = document.getElementById('histCanvas');
+  const rect   = canvas.getBoundingClientRect();
+  canvas.width  = rect.width * window.devicePixelRatio;
+  canvas.height = rect.height * window.devicePixelRatio;
+  const ctx = canvas.getContext('2d');
+  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
+
+  const w = rect.width;
+  const h = rect.height;
+
+  ctx.fillStyle = "#050505";
+  ctx.fillRect(0,0,w,h);
+
+  if(!samples || samples.length === 0) return;
+
+  // limiti temperatura
+  let minT = 999, maxT = -999;
+  samples.forEach(s=>{
+    if(s.t1 !== null && s.t1 !== undefined){
+      minT = Math.min(minT, s.t1);
+      maxT = Math.max(maxT, s.t1);
+    }
+    if(s.t2 !== null && s.t2 !== undefined){
+      minT = Math.min(minT, s.t2);
+      maxT = Math.max(maxT, s.t2);
+    }
+  });
+  if(minT === 999){
+    minT = 20; maxT = 80;
+  }else{
+    minT -= 5; maxT += 5;
+  }
+  const marginL = 28, marginR = 4, marginT = 4, marginB = 14;
+  const plotW = w - marginL - marginR;
+  const plotH = h - marginT - marginB;
+
+  // griglia
+  ctx.strokeStyle = "#222";
+  ctx.lineWidth = 1;
+  ctx.beginPath();
+  for(let i=0;i<=4;i++){
+    const y = marginT + (plotH * i/4);
+    ctx.moveTo(marginL, y);
+    ctx.lineTo(w-marginR, y);
+  }
+  ctx.stroke();
+
+  // scala Y temperature testi
+  ctx.fillStyle = "#777";
+  ctx.font = "10px sans-serif";
+  for(let i=0;i<=4;i++){
+    const t = minT + (maxT-minT)*i/4;
+    const y = marginT + (plotH * i/4);
+    ctx.fillText(t.toFixed(0), 2, y+3);
+  }
+
+  // funzione per mappare t -> y
+  function yForTemp(temp){
+    if(temp === null || temp === undefined) return null;
+    const ratio = (temp - minT) / (maxT - minT);
+    const y = marginT + (1-ratio)*plotH;
+    return y;
+  }
+
+  // X step
+  const n = samples.length;
+  const dx = (n>1) ? (plotW/(n-1)) : 0;
+
+  // Pompa: rettangoli in basso
+  ctx.fillStyle = "rgba(76,175,80,0.4)";
+  for(let i=0;i<n;i++){
+    const s = samples[i];
+    if(s.p){
+      const x = marginL + dx*i - 2;
+      const y = marginT + plotH + 2;
+      ctx.fillRect(x, y, 4, marginB-4);
+    }
+  }
+
+  // P1 (linea accent2)
+  ctx.strokeStyle = "#4caf50";
+  ctx.lineWidth = 1.5;
+  ctx.beginPath();
+  let first = true;
+  for(let i=0;i<n;i++){
+    const s = samples[i];
+    const y = yForTemp(s.t1);
+    if(y === null) continue;
+    const x = marginL + dx*i;
+    if(first){ ctx.moveTo(x,y); first=false; }
+    else ctx.lineTo(x,y);
+  }
+  ctx.stroke();
+
+  // P2 (linea blu)
+  ctx.strokeStyle = "#2196f3";
+  ctx.lineWidth = 1;
+  ctx.beginPath();
+  first = true;
+  for(let i=0;i<n;i++){
+    const s = samples[i];
+    const y = yForTemp(s.t2);
+    if(y === null) continue;
+    const x = marginL + dx*i;
+    if(first){ ctx.moveTo(x,y); first=false; }
+    else ctx.lineTo(x,y);
+  }
+  ctx.stroke();
+}
+
+// FETCH STATUS & SETTINGS & HISTORY
+
+async function fetchStatus(){
+  try{
+    const r = await fetch('/api/status');
+    const s = await r.json();
+    statusData = s;
+    updateSchemaFromStatus(s);
+    updateWidgetsFromStatus(s);
+  }catch(e){
+    console.error("status", e);
+  }
+}
+
+async function fetchSettings(){
+  try{
+    const r = await fetch('/api/settings');
+    const s = await r.json();
+    // Pompa
+    if(s.pumpMode){
+      if(s.pumpMode.indexOf("AUTO")===0) document.getElementById('selPumpMode').value = "AUTO";
+      else if(s.pumpMode.indexOf("ON")>=0) document.getElementById('selPumpMode').value = "ON";
+      else if(s.pumpMode.indexOf("OFF")>=0) document.getElementById('selPumpMode').value = "OFF";
+    }
+    document.getElementById('numPumpSet').value = s.pumpSetTemp ?? 45.0;
+
+    // Display
+    document.getElementById('rangeContrast').value = s.contrast ?? 200;
+    document.getElementById('selFlip').value = s.flip ?? 0;
+
+    // AUX
+    document.getElementById('chkAux').checked = !!s.auxOn;
+
+    // Puffer & sonde
+    document.getElementById('chkP1').checked = !!s.puffer1Enabled;
+    document.getElementById('chkP2').checked = !!s.puffer2Enabled;
+    document.getElementById('chkS1').checked = !!s.s1Enabled;
+    document.getElementById('chkS2').checked = !!s.s2Enabled;
+    document.getElementById('chkS3').checked = !!s.s3Enabled;
+    document.getElementById('chkS4').checked = !!s.s4Enabled;
+
+    // Orologio
+    document.getElementById('chkNtp').checked = !!s.clockUseNtp;
+    document.getElementById('chk24h').checked = !!s.clockIs24h;
+    if(typeof s.clockTzIndex === 'number'){
+      document.getElementById('selTz').value = s.clockTzIndex;
+    }
+
+    // Tema
+    if(typeof s.theme === 'number'){
+      document.getElementById('selTheme').value = s.theme;
+      applyWebTheme(s.theme);
+    }
+
+  }catch(e){
+    console.error("settings", e);
+  }
+}
+
+async function fetchHistory(){
+  try{
+    const r = await fetch('/api/history');
+    const s = await r.json();
+    lastHistory = s.samples || [];
+    drawHistoryCanvas(lastHistory);
+  }catch(e){
+    console.error("history", e);
+  }
+}
+
+// Salvataggio impostazioni
+document.getElementById('btnSaveSettings').addEventListener('click', async ()=>{
+  const pm   = document.getElementById('selPumpMode').value;
+  const setT = document.getElementById('numPumpSet').value;
+  const c    = document.getElementById('rangeContrast').value;
+  const flip = document.getElementById('selFlip').value;
+  const theme= document.getElementById('selTheme').value;
+
+  const aux  = document.getElementById('chkAux').checked;
+
+  const p1   = document.getElementById('chkP1').checked;
+  const p2   = document.getElementById('chkP2').checked;
+  const s1   = document.getElementById('chkS1').checked;
+  const s2   = document.getElementById('chkS2').checked;
+  const s3   = document.getElementById('chkS3').checked;
+  const s4   = document.getElementById('chkS4').checked;
+
+  const ntp  = document.getElementById('chkNtp').checked;
+  const h24  = document.getElementById('chk24h').checked;
+  const tz   = document.getElementById('selTz').value;
+
+  const body = new URLSearchParams();
+  body.append('pumpMode', pm);
+  body.append('pumpSetTemp', setT);
+  body.append('contrast', c);
+  body.append('flip', flip);
+  body.append('theme', theme);
+
+  body.append('auxOn', aux ? '1' : '0');
+  body.append('puffer1Enabled', p1 ? '1' : '0');
+  body.append('puffer2Enabled', p2 ? '1' : '0');
+  body.append('s1Enabled', s1 ? '1' : '0');
+  body.append('s2Enabled', s2 ? '1' : '0');
+  body.append('s3Enabled', s3 ? '1' : '0');
+  body.append('s4Enabled', s4 ? '1' : '0');
+
+  body.append('clockUseNtp', ntp ? '1' : '0');
+  body.append('clockIs24h', h24 ? '1' : '0');
+  body.append('clockTzIndex', tz);
+
+  try{
+    await fetch('/api/settings', {method:'POST', body});
+    await fetchStatus();
+    await fetchSettings();
+  }catch(e){
+    console.error("save settings", e);
+  }
+});
+
+// Init
+(async function init(){
+  if(isTodayChristmas()){
+    document.body.classList.add("theme-christmas");
+    document.getElementById('christmasBadge').textContent = "🎄 Buon Natale!";
+  }
+  await fetchStatus();
+  await fetchSettings();
+  await fetchHistory();
+  setInterval(fetchStatus, 3000);
+  setInterval(fetchHistory, 60000);
+})();
+</script>
+</body>
+</html>
+)====";
+
+// =============================
+//  ROUTE WEB SERVER
+// =============================
+
+void handleApp() {
+  server.send_P(200, "text/html", APP_HTML);
+}
+
+// =============================
+//  WEB SERVER: HANDLER BASE
+// =============================
+
+// Pagina principale con info rapida e link alla WebApp
+void handleRoot() {
+  String page =
+    F("<!DOCTYPE html><html><head><meta charset='utf-8'>"
+      "<title>TermoSystem WiFi</title>"
+      "<meta name='viewport' content='width=device-width,initial-scale=1'>"
+      "<style>"
+      "body{font-family:Arial;background:#111;color:#eee;text-align:center;padding:20px;}"
+      "h1{color:#4caf50;}"
+      "a{color:#4caf50;text-decoration:none;font-weight:bold;}"
+      "div.card{background:#1e1e1e;border-radius:12px;padding:16px;margin:10px auto;max-width:400px;"
+      "box-shadow:0 0 10px #00000066;}"
+      "</style>"
+      "</head><body>");
+
+  page += F("<h1>TermoSystem</h1>");
+  page += F("<div class='card'>");
+
+  page += F("<p>Controller riscaldamento</p>");
+  page += F("<p>Firmware: ");
+  page += FW_VERSION;
+  page += F("</p>");
+
+  if (wifiConnected) {
+    page += F("<p><b>WiFi:</b> Connesso a <b>");
+    page += WiFi.SSID();
+    page += F("</b><br>IP: ");
+    page += WiFi.localIP().toString();
+    page += F("</p>");
+  } else {
+    page += F("<p><b>WiFi:</b> Non connesso alla rete di casa</p>");
+    page += F("<p>Modalità AP: <code>TermoSystemWifi</code><br>IP: <code>192.168.4.1</code></p>");
+  }
+
+  page += F("<p><a href='/wifi'>Configura WiFi</a></p>");
+  page += F("<p><a href='/app'>Apri WebApp TermoSystem</a></p>");
+  page += F("</div></body></html>");
+
+  server.send(200, "text/html", page);
+}
+
+// Pagina di configurazione WiFi
+void handleWifiPage() {
+  String page =
+    F("<!DOCTYPE html><html><head><meta charset='utf-8'>"
+      "<title>Config WiFi</title>"
+      "<meta name='viewport' content='width=device-width,initial-scale=1'>"
+      "<style>"
+      "body{font-family:Arial;background:#111;color:#eee;text-align:center;padding:20px;}"
+      "h1{color:#4caf50;}"
+      "select,input{padding:6px;margin:5px;border-radius:6px;border:1px solid #555;"
+      "background:#222;color:#eee;}"
+      "button{padding:8px 16px;border:none;border-radius:8px;background:#4caf50;color:#fff;"
+      "cursor:pointer;font-weight:bold;}"
+      "button:active{transform:scale(0.97);}"
+      "a{color:#4caf50;text-decoration:none;}"
+      "div.card{background:#1e1e1e;border-radius:12px;padding:16px;margin:10px auto;max-width:420px;"
+      "box-shadow:0 0 10px #00000066;}"
+      "</style>"
+      "</head><body>");
+
+  page += F("<h1>Config WiFi</h1>");
+  page += F("<div class='card'>");
+
+  if (wifiConnected) {
+    page += F("<p>Attualmente connesso a <b>");
+    page += WiFi.SSID();
+    page += F("</b><br>IP: ");
+    page += WiFi.localIP().toString();
+    page += F("</p><hr>");
+  } else {
+    page += F("<p>Non connesso alla rete di casa.</p><hr>");
+  }
+
+  page += F("<form method='POST' action='/saveWifi'>"
+            "<p>Reti disponibili:</p>");
+
+  int n = WiFi.scanNetworks();
+  if (n <= 0) {
+    page += F("<p>Nessuna rete trovata. Riprova tra qualche secondo.</p>");
+  } else {
+    page += F("<select name='ssid'>");
+    for (int i = 0; i < n; i++) {
+      page += F("<option value='");
+      page += WiFi.SSID(i);
+      page += F("'>");
+      page += WiFi.SSID(i);
+      page += F(" (");
+      page += WiFi.RSSI(i);
+      page += F(" dBm)</option>");
+    }
+    page += F("</select><br>");
+  }
+
+  page += F("<p>Password:</p>"
+            "<input type='password' name='password' placeholder='Password WiFi'><br><br>"
+            "<button type='submit'>Salva & Riavvia</button>"
+            "</form>");
+
+  page += F("<p style='margin-top:12px;'><a href='/app'>Vai alla WebApp</a></p>");
+  page += F("<p><a href='/'>Torna alla home</a></p>");
+
+  page += F("</div></body></html>");
+
+  server.send(200, "text/html", page);
+}
+
+// Salvataggio WiFi e riavvio
+void handleSaveWifi() {
+  if (server.method() != HTTP_POST) {
+    server.send(405, "text/plain", "Metodo non valido");
+    return;
+  }
+
+  String ssid = server.arg("ssid");
+  String pass = server.arg("password");
+
+  if (ssid.length() == 0) {
+    server.send(400, "text/plain", "SSID mancante");
+    return;
+  }
+
+  saveWifiConfig(ssid.c_str(), pass.c_str());
+
+  String page =
+    F("<!DOCTYPE html><html><head><meta charset='utf-8'>"
+      "<title>WiFi salvato</title>"
+      "<meta name='viewport' content='width=device-width,initial-scale=1'>"
+      "<style>"
+      "body{font-family:Arial;background:#111;color:#eee;text-align:center;padding:20px;}"
+      "h1{color:#4caf50;}"
+      "</style></head><body>"
+      "<h1>Configurazione salvata</h1>"
+      "<p>Il dispositivo si riavviera' tra pochi secondi.</p>"
+      "<p>Collegati poi alla rete di casa e visita di nuovo l'indirizzo del TermoSystem.</p>"
+      "</body></html>");
+
+  server.send(200, "text/html", page);
+  delay(1000);
+  ESP.restart();
+}
+
+void setupWebServerRoutes() {
+  server.on("/",          handleRoot);
+  server.on("/wifi",      handleWifiPage);
+  server.on("/saveWifi",  handleSaveWifi);
+
+  server.on("/api/status",   handleApiStatus);
+  server.on("/api/settings", HTTP_GET,  handleApiSettingsGet);
+  server.on("/api/settings", HTTP_POST, handleApiSettingsPost);
+  server.on("/api/history",  handleApiHistory);
+
+  server.on("/app", handleApp);
+}
